<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Riba Run – 3D Kestrl Edition</title>

  <!-- Tailwind for HUD -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.161.0/build/three.min.js"></script>
  <!-- React + ReactDOM + Babel -->
  <script src="https://unpkg.com/react@17/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #020617;
      color: #e5e7eb;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text", sans-serif;
    }
    #three-root {
      position: fixed;
      inset: 0;
      z-index: 0;
    }
    #hud-root {
      position: fixed;
      inset: 0;
      z-index: 10;
      pointer-events: none;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <div id="three-root"></div>
  <div id="hud-root"></div>

  <!-- HUD / React UI -->
  <script type="text/babel">
    const { useState, useEffect } = React;

    function GameHUD() {
      const [state, setState] = useState({
        balance: 500,
        score: 0,
        barakahActive: false,
        fogLevel: 1,
        loanTaken: false,
        showLoanModal: false,
        gameOver: false,
        gameOverReason: "",
        monsterThreat: 0,
      });

      useEffect(() => {
        window.updateHUD = (updates) => {
          setState(prev => ({ ...prev, ...updates }));
        };
        window.showLoanModal = () => {
          setState(prev => ({ ...prev, showLoanModal: true }));
        };
        window.hideLoanModal = () => {
          setState(prev => ({ ...prev, showLoanModal: false }));
        };
      }, []);

      const balanceColor =
        state.balance > 400 ? "text-emerald-300" :
        state.balance > 200 ? "text-yellow-300" :
        state.balance > 0   ? "text-red-300" :
                              "text-red-500";

      const threatPercent = Math.min(100, Math.max(0, state.monsterThreat * 20));

      return (
        <div className="w-full h-full flex flex-col">
          {/* TOP HUD BAR */}
          <div className="pointer-events-none flex justify-between items-start p-4 gap-4">
            {/* LEFT: Balance & Distance */}
            <div className="space-y-2">
              <div className="bg-slate-900/70 border border-slate-700/80 rounded-xl px-4 py-2 shadow-lg shadow-emerald-500/10">
                <div className="flex items-center justify-between gap-4">
                  <span className="text-xs tracking-[0.2em] text-slate-400 uppercase">
                    Bank Balance
                  </span>
                  <span className={`font-mono text-xl font-semibold ${balanceColor}`}>
                    £{Math.floor(state.balance)}
                  </span>
                </div>
                <div className="mt-1 text-xs text-slate-400">
                  Expenses are draining every frame. Stay halal, stay disciplined.
                </div>
              </div>

              <div className="bg-slate-900/60 border border-slate-700/80 rounded-xl px-4 py-2 shadow shadow-slate-900/60">
                <div className="flex items-center justify-between gap-4">
                  <span className="text-xs tracking-[0.25em] text-slate-500 uppercase">
                    Distance
                  </span>
                  <span className="font-mono text-lg text-sky-300">
                    {Math.floor(state.score)} m
                  </span>
                </div>
                <div className="mt-1 text-[11px] text-slate-500">
                  The Tunnel of Wants stretches on…
                </div>
              </div>
            </div>

            {/* CENTER: Barakah & Threat */}
            <div className="flex flex-col items-center gap-3 pointer-events-none">
              {/* Barakah (Sadaqah) */}
              <div className="bg-slate-950/70 border border-emerald-500/40 rounded-2xl px-4 py-2 shadow-lg shadow-emerald-500/25 min-w-[260px]">
                <div className="flex justify-between items-center text-xs text-slate-300 mb-1">
                  <span className="tracking-[0.25em] uppercase text-emerald-300">
                    Barakah
                  </span>
                  <span className="text-slate-400">
                    Press <span className="font-mono text-emerald-300">S</span> to give Sadaqah
                  </span>
                </div>
                <div className="relative h-2.5 rounded-full bg-slate-800 overflow-hidden">
                  <div
                    className={
                      "absolute inset-y-0 left-0 transition-all duration-300 " +
                      (state.barakahActive
                        ? "w-full bg-gradient-to-r from-emerald-400 via-emerald-300 to-emerald-500 shadow-[0_0_20px_rgba(52,211,153,0.9)]"
                        : "w-1/6 bg-slate-700")
                    }
                  />
                </div>
                <div className="mt-1 text-[11px] text-slate-400">
                  {state.barakahActive
                    ? "Hidden blessing: each coin quietly gives more than it shows."
                    : "Costs £100 now, but eases your path ahead."}
                </div>
              </div>

              {/* Debt Threat */}
              <div className="bg-slate-950/60 border border-rose-500/40 rounded-2xl px-4 py-2 shadow-lg shadow-rose-500/25 min-w-[260px]">
                <div className="flex items-center justify-between text-xs text-slate-300 mb-1">
                  <span className="tracking-[0.25em] uppercase text-rose-300">
                    Debt Threat
                  </span>
                  <span className="font-mono text-xs text-rose-200">
                    {Math.round(threatPercent)}%
                  </span>
                </div>
                <div className="relative h-2 rounded-full bg-slate-800 overflow-hidden">
                  <div
                    className="absolute inset-y-0 left-0 bg-gradient-to-r from-emerald-400 via-yellow-300 to-rose-500"
                    style={{ width: `${threatPercent}%` }}
                  />
                </div>
                <div className="mt-1 text-[11px] text-slate-400">
                  Green orbs push the Monster back. Red pyramids feed it.
                </div>
              </div>
            </div>

            {/* RIGHT: Controls */}
            <div className="pointer-events-none">
              <div className="bg-slate-900/80 border border-slate-700 rounded-xl px-4 py-2 text-xs text-slate-300 shadow shadow-slate-900/80">
                <div className="font-semibold text-slate-100 mb-1 text-[11px] tracking-[0.22em] uppercase">
                  Controls
                </div>
                <ul className="space-y-0.5 font-mono text-[11px]">
                  <li>← → : Switch Lanes</li>
                  <li>↑ / Space : Jump</li>
                  <li>S : Sadaqah (Barakah boost)</li>
                  <li>Yellow Arch : Investment Gate</li>
                  <li>Blue Diamond : Kestrl Card</li>
                </ul>
              </div>
            </div>
          </div>

          {/* LOAN MODAL */}
          {state.showLoanModal && (
            <div className="pointer-events-auto fixed inset-0 flex items-center justify-center bg-slate-950/70 backdrop-blur-sm">
              <div className="bg-slate-900 border border-slate-700 rounded-2xl max-w-md w-full mx-4 p-6 shadow-2xl shadow-rose-900/40">
                <div className="flex items-center gap-3 mb-4">
                  <div className="w-9 h-9 rounded-full bg-rose-500/20 flex items-center justify-center">
                    <span className="text-rose-400 text-lg">!</span>
                  </div>
                  <div>
                    <h2 className="text-lg font-semibold text-slate-50">
                      Balance Depleted
                    </h2>
                    <p className="text-xs text-slate-400">
                      The Riba Monster looms over you. What will you choose?
                    </p>
                  </div>
                </div>
                <div className="space-y-3 text-sm text-slate-300 mb-5">
                  <p>
                    You’ve hit <span className="font-mono text-rose-300">£0</span>. 
                    Many people are tempted to “solve” this with interest-bearing loans.
                  </p>
                  <p className="text-slate-400">
                    In this moment, you have two paths:
                  </p>
                  <ul className="list-disc list-inside text-slate-300 text-xs space-y-1">
                    <li>
                      <span className="font-semibold text-emerald-300">Accept Bankruptcy</span>: End the run now and walk away from Riba.
                    </li>
                    <li>
                      <span className="font-semibold text-rose-300">Take Riba Loan (+£1000)</span>: Continue, but expenses double and the Monster clings to you. One mistake, and it’s over.
                    </li>
                  </ul>
                </div>
                <div className="flex flex-col sm:flex-row gap-3 justify-end">
                  <button
                    onClick={() => window.acceptBankruptcy && window.acceptBankruptcy()}
                    className="flex-1 sm:flex-none inline-flex items-center justify-center px-4 py-2 rounded-xl border border-emerald-500/80 text-emerald-200 text-sm font-medium bg-emerald-950/40 hover:bg-emerald-900/60 transition"
                  >
                    Accept Bankruptcy
                  </button>
                  <button
                    onClick={() => window.takeLoan && window.takeLoan()}
                    className="flex-1 sm:flex-none inline-flex items-center justify-center px-4 py-2 rounded-xl border border-rose-500/80 text-rose-100 text-sm font-semibold bg-rose-900/60 hover:bg-rose-800/90 transition shadow-lg shadow-rose-900/70"
                  >
                    Take Riba Loan (+£1000)
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* GAME OVER BANNER */}
          {state.gameOver && (
            <div className="pointer-events-auto fixed inset-x-0 bottom-10 flex justify-center">
              <div className="bg-slate-950/90 border border-slate-700 rounded-2xl px-6 py-4 shadow-2xl shadow-slate-900/80 max-w-xl mx-4">
                <div className="text-sm text-slate-100 font-semibold mb-1">
                  {state.gameOverReason || "Game Over"}
                </div>
                <p className="text-xs text-slate-400 mb-3">
                  Press <span className="font-mono text-emerald-300">R</span> to restart and try to stay Riba-free.
                </p>
              </div>
            </div>
          )}
        </div>
      );
    }

    ReactDOM.render(<GameHUD />, document.getElementById("hud-root"));
  </script>

  <!-- Three.js Game Logic -->
  <script type="text/babel">
    let scene, camera, renderer, clock;
    let player, monster;
    let laneIndex = 1;
    const lanes = [-3, 0, 3];

    let playerY = 1;
    let velocityY = 0;
    const gravity = -25;

    let objects = []; // { mesh, type, lane }
    let investmentTimers = []; // { framesLeft, paid }

    let speed = 26; // forward
    let balance = 500;
    let score = 0;
    let drainMultiplier = 1;
    let baseDrainPerFrame = 1;
    let drainAccumulator = 0;

    let threatLevel = 1.5;
    let monsterZ = 8;
    let monsterTargetZ = 8;

    let barakahActive = false;
    let barakahTimeLeft = 0;
    const barakahMultiplier = 2;
    const barakahScoreMultiplier = 2;

    let kestrlActive = false;
    let kestrlTimeLeft = 0;

    let fogDensityBase = 0.06;
    let fogDensityBarakah = 0.02;

    let lastSpawnTime = 0;
    let lastGateTime = 0;
    let lastKestrlTime = 0;

    let isPaused = false;
    let isGameOver = false;
    let loanTaken = false;

    const threeRoot = document.getElementById("three-root");

    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x020617);
      scene.fog = new THREE.FogExp2(0x020617, fogDensityBase);

      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 200);
      camera.position.set(0, 6, 10);
      camera.lookAt(0, 2, 0);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio || 1);
      threeRoot.appendChild(renderer.domElement);

      // Lights
      const hemi = new THREE.HemisphereLight(0x0f172a, 0x000000, 0.9);
      scene.add(hemi);

      const dir = new THREE.DirectionalLight(0x38bdf8, 0.9);
      dir.position.set(6, 10, 6);
      scene.add(dir);

      // Cyber tunnel floor
      const floorGeo = new THREE.PlaneGeometry(40, 400, 20, 120);
      const floorMat = new THREE.MeshBasicMaterial({
        color: 0x020617,
        wireframe: true,
      });
      const floor = new THREE.Mesh(floorGeo, floorMat);
      floor.rotation.x = -Math.PI / 2;
      floor.position.z = -180;
      scene.add(floor);

      // Neon lane lines
      const laneMat = new THREE.LineBasicMaterial({ color: 0x22c55e });
      for (let i = 0; i < lanes.length; i++) {
        const laneX = lanes[i];
        const points = [];
        points.push(new THREE.Vector3(laneX, 0.01, -200));
        points.push(new THREE.Vector3(laneX, 0.01, 20));
        const geo = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geo, laneMat);
        scene.add(line);
      }

      // Player (Kestrl cube)
      const playerGeo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
      const playerMat = new THREE.MeshStandardMaterial({
        color: 0x22c55e,
        emissive: 0x22c55e,
        emissiveIntensity: 0.8,
        metalness: 0.4,
        roughness: 0.3,
      });
      player = new THREE.Mesh(playerGeo, playerMat);
      player.position.set(lanes[laneIndex], playerY, 0);
      scene.add(player);

      // Monster (shadow cube)
      const monsterGeo = new THREE.BoxGeometry(1.7, 1.7, 1.7);
      const monsterMat = new THREE.MeshStandardMaterial({
        color: 0x020617,
        emissive: 0x7f1d1d,
        emissiveIntensity: 0.4,
        metalness: 0.2,
        roughness: 0.9,
      });
      monster = new THREE.Mesh(monsterGeo, monsterMat);
      monster.position.set(0, 1.3, monsterZ);
      scene.add(monster);

      // Floating neon cubes (environment)
      for (let i = 0; i < 40; i++) {
        const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
        const mat = new THREE.MeshBasicMaterial({
          color: Math.random() > 0.5 ? 0x38bdf8 : 0x22c55e,
        });
        const cube = new THREE.Mesh(geo, mat);
        cube.position.set(
          (Math.random() - 0.5) * 20,
          0.2 + Math.random() * 6,
          -Math.random() * 200
        );
        scene.add(cube);
      }

      clock = new THREE.Clock();

      window.addEventListener("resize", onWindowResize);
      window.addEventListener("keydown", onKeyDown);

      resetGame();
      animate();
    }

    function resetGame() {
      balance = 500;
      score = 0;
      drainMultiplier = 1;
      baseDrainPerFrame = 1;
      drainAccumulator = 0;

      threatLevel = 1.5;
      monsterZ = 8;
      monsterTargetZ = 8;

      laneIndex = 1;
      player.position.x = lanes[laneIndex];
      playerY = 1;
      player.position.y = playerY;
      velocityY = 0;

      barakahActive = false;
      barakahTimeLeft = 0;
      kestrlActive = false;
      kestrlTimeLeft = 0;
      loanTaken = false;
      isPaused = false;
      isGameOver = false;

      scene.background = new THREE.Color(0x020617);
      scene.fog.density = fogDensityBase;

      // Clear objects
      objects.forEach(o => scene.remove(o.mesh));
      objects = [];
      investmentTimers = [];

      lastSpawnTime = 0;
      lastGateTime = 0;
      lastKestrlTime = 0;
      clock.getDelta();

      updateHUD({
        balance,
        score,
        barakahActive,
        fogLevel: 1,
        loanTaken,
        gameOver: false,
        gameOverReason: "",
        monsterThreat: threatLevel,
        showLoanModal: false,
      });
    }

    function onWindowResize() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }

    function onKeyDown(e) {
      if (e.code === "ArrowLeft") {
        if (!isPaused && !isGameOver) {
          laneIndex = Math.max(0, laneIndex - 1);
          player.position.x = lanes[laneIndex];
        }
      } else if (e.code === "ArrowRight") {
        if (!isPaused && !isGameOver) {
          laneIndex = Math.min(lanes.length - 1, laneIndex + 1);
          player.position.x = lanes[laneIndex];
        }
      } else if (e.code === "ArrowUp" || e.code === "Space") {
        if (!isPaused && !isGameOver && playerY <= 1.01) {
          velocityY = 11;
        }
      } else if (e.code === "KeyS") {
        if (!isPaused && !isGameOver) {
          triggerSadaqah();
        }
      } else if (e.code === "KeyR") {
        if (isGameOver) {
          resetGame();
        }
      }
    }

    function triggerSadaqah() {
      if (balance >= 100 && !barakahActive) {
        balance -= 100;
        barakahActive = true;
        barakahTimeLeft = 15;
        scene.fog.density = fogDensityBarakah;
        updateHUD({
          balance,
          barakahActive,
          fogLevel: 0.3,
        });
      }
    }

    function spawnObject(type) {
      let mesh;
      const lane = lanes[Math.floor(Math.random() * lanes.length)];
      const z = -80 - Math.random() * 40;

      if (type === "greenCoin") {
        const geo = new THREE.SphereGeometry(0.45, 16, 16);
        const mat = new THREE.MeshStandardMaterial({
          color: 0x22c55e,
          emissive: 0xfacc15,
          emissiveIntensity: 1.2,
          metalness: 0.3,
          roughness: 0.25,
        });
        mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(lane, 1.2, z);
      } else if (type === "redCoin") {
        const geo = new THREE.ConeGeometry(0.5, 0.95, 20);
        const mat = new THREE.MeshStandardMaterial({
          color: 0x991b1b,
          emissive: 0xef4444,
          emissiveIntensity: 1.1,
          metalness: 0.3,
          roughness: 0.3,
        });
        mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(lane, 1.2, z);
      } else if (type === "obstacle") {
        const geo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
        const mat = new THREE.MeshStandardMaterial({
          color: 0x334155,
          emissive: 0x020617,
          emissiveIntensity: 0.8,
          metalness: 0.6,
          roughness: 0.4,
        });
        mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(lane, 0.6, z);
      } else if (type === "investmentGate") {
        const geo = new THREE.TorusGeometry(1.4, 0.13, 12, 32);
        const mat = new THREE.MeshStandardMaterial({
          color: 0xfacc15,
          emissive: 0xf59e0b,
          emissiveIntensity: 1.1,
          metalness: 0.7,
          roughness: 0.3,
        });
        mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = Math.PI / 2;
        mesh.position.set(lane, 1.5, z);
      } else if (type === "kestrlCard") {
        const geo = new THREE.OctahedronGeometry(0.6);
        const mat = new THREE.MeshStandardMaterial({
          color: 0x38bdf8,
          emissive: 0x22d3ee,
          emissiveIntensity: 1.3,
          metalness: 0.6,
          roughness: 0.2,
        });
        mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(lane, 2, z);
      }

      if (mesh) {
        scene.add(mesh);
        objects.push({ mesh, type, lane });
      }
    }

    function addBalance(baseAmount) {
      const multiplier = barakahActive ? barakahMultiplier : 1;
      balance += baseAmount * multiplier;
    }

    function updateInvestments(dt) {
      const framesPassed = dt * 60;
      for (let i = investmentTimers.length - 1; i >= 0; i--) {
        const inv = investmentTimers[i];
        inv.framesLeft -= framesPassed;
        if (inv.framesLeft <= 0 && !inv.paid) {
          inv.paid = true;
          addBalance(600); // hidden barakah handled in addBalance
          investmentTimers.splice(i, 1);
        }
      }
    }

    function updateMonster(dt) {
      const baseZ = 10;
      const minZ = 1.5;
      const maxZ = 15;

      monsterTargetZ = baseZ - threatLevel * 2;
      monsterTargetZ = Math.min(maxZ, Math.max(minZ, monsterTargetZ));

      if (kestrlActive) {
        monsterTargetZ = 18;
      }

      // If loan taken, monster wants to be closer overall
      if (loanTaken && !kestrlActive) {
        monsterTargetZ = Math.max(2, monsterTargetZ - 1.5);
      }

      monsterZ += (monsterTargetZ - monsterZ) * 3 * dt;
      monster.position.z = monsterZ;

      // Pulsing emissive based on threat
      const intensity = kestrlActive
        ? 0.1
        : 0.3 + Math.min(1.2, threatLevel * 0.25);
      monster.material.emissiveIntensity = intensity;

      // Monster catch
      if (!isGameOver && !isPaused && monsterZ <= 1.3) {
        gameOver("Game Over: Consumed by Debt.");
      }
    }

    function gameOver(reason) {
      isGameOver = true;
      isPaused = true;
      updateHUD({
        gameOver: true,
        gameOverReason: reason,
        showLoanModal: false,
      });
    }

    window.acceptBankruptcy = function() {
      if (!isPaused) return;
      gameOver("You accepted bankruptcy and walked away from Riba.");
    };

    window.takeLoan = function() {
      if (!isPaused || isGameOver) return;
      balance += 1000;
      drainMultiplier *= 2;
      loanTaken = true;
      threatLevel += 2.5;
      monsterZ = 2;
      monsterTargetZ = 2;
      isPaused = false;
      window.hideLoanModal && window.hideLoanModal();
      updateHUD({
        balance,
        loanTaken,
        showLoanModal: false,
      });
    };

    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      if (!isPaused && !isGameOver) {
        update(dt);
      }
      renderer.render(scene, camera);
    }

    function update(dt) {
      const elapsed = clock.elapsedTime;

      // Distance (score)
      score += speed * dt * (barakahActive ? barakahScoreMultiplier : 1);

      // Expense drain: -£1 per frame (approx 60fps)
      const frames = dt * 60 * drainMultiplier;
      drainAccumulator += frames;
      while (drainAccumulator >= 1) {
        balance -= baseDrainPerFrame;
        drainAccumulator -= 1;
      }

      // Barakah timer
      if (barakahActive) {
        barakahTimeLeft -= dt;
        if (barakahTimeLeft <= 0) {
          barakahActive = false;
          scene.fog.density = fogDensityBase;
        }
      }

      // Kestrl Card timer
      if (kestrlActive) {
        kestrlTimeLeft -= dt;
        if (kestrlTimeLeft <= 0) {
          kestrlActive = false;
          scene.background = new THREE.Color(0x020617);
        }
      }

      // Bankruptcy check
      if (balance <= 0 && !isPaused && !isGameOver) {
        balance = 0;
        isPaused = true;
        window.showLoanModal && window.showLoanModal();
      }

      // Jump physics
      velocityY += gravity * dt;
      playerY += velocityY * dt;
      if (playerY <= 1) {
        playerY = 1;
        velocityY = 0;
      }
      player.position.y = playerY;

      // Spawn objects
      if (elapsed - lastSpawnTime > 0.6) {
        const r = Math.random();
        if (r < 0.45) {
          spawnObject("greenCoin");
        } else if (r < 0.75) {
          spawnObject("redCoin");
        } else {
          spawnObject("obstacle");
        }
        lastSpawnTime = elapsed;
      }
      if (elapsed - lastGateTime > 8) {
        spawnObject("investmentGate");
        lastGateTime = elapsed;
      }
      if (elapsed - lastKestrlTime > 18) {
        spawnObject("kestrlCard");
        lastKestrlTime = elapsed;
      }

      // Move objects & collisions
      for (let i = objects.length - 1; i >= 0; i--) {
        const o = objects[i];
        o.mesh.position.z += speed * dt;

        if (o.type === "greenCoin" || o.type === "redCoin" || o.type === "kestrlCard") {
          o.mesh.rotation.y += 2.2 * dt;
        }
        if (o.type === "investmentGate") {
          o.mesh.rotation.z += 1.8 * dt;
        }

        if (o.mesh.position.z > 12) {
          scene.remove(o.mesh);
          objects.splice(i, 1);
          continue;
        }

        // Lane + z-distance collision
        if (o.lane === lanes[laneIndex]) {
          const dz = Math.abs(o.mesh.position.z - player.position.z);
          if (dz < 0.9) {
            if (o.type === "obstacle") {
              scene.remove(o.mesh);
              objects.splice(i, 1);
              gameOver("You stumbled over an obstacle and Debt caught you.");
              continue;
            } else if (o.type === "greenCoin") {
              scene.remove(o.mesh);
              objects.splice(i, 1);
              addBalance(10);
              threatLevel = Math.max(0.2, threatLevel - 0.25);
            } else if (o.type === "redCoin") {
              scene.remove(o.mesh);
              objects.splice(i, 1);
              addBalance(50);
              threatLevel += 0.5;
            } else if (o.type === "investmentGate") {
              scene.remove(o.mesh);
              objects.splice(i, 1);
              if (balance >= 200) {
                balance -= 200;
                investmentTimers.push({ framesLeft: 600, paid: false }); // ~10s at 60fps
              }
            } else if (o.type === "kestrlCard") {
              scene.remove(o.mesh);
              objects.splice(i, 1);

              kestrlActive = true;
              kestrlTimeLeft = 10;
              scene.background = new THREE.Color(0xf9fafb);

              // Clean slate: monster back + threat reset
              threatLevel = 0.2;
              monsterZ = 18;
              monsterTargetZ = 18;

              // Flip all existing red → green
              for (const oo of objects) {
                if (oo.type === "redCoin") {
                  oo.type = "greenCoin";
                  oo.mesh.geometry = new THREE.SphereGeometry(0.45, 16, 16);
                  oo.mesh.material.color.setHex(0x22c55e);
                  oo.mesh.material.emissive.setHex(0xfacc15);
                }
              }
            }
          }
        }
      }

      // Investments
      updateInvestments(dt);

      // Monster
      updateMonster(dt);

      // Subtle camera motion
      camera.position.y = 5.5 + Math.sin(elapsed * 1.6) * 0.12;
      camera.lookAt(0, 2, 0);

      // HUD
      updateHUD({
        balance,
        score,
        barakahActive,
        fogLevel: barakahActive ? 0.3 : 1,
        loanTaken,
        monsterThreat: threatLevel,
      });
    }

    // Kick off
    initThree();
  </script>
</body>
</html>

















    


