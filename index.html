<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Halal Realm – Riba Run</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: #020617;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #gameCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
      cursor: crosshair;
    }
  </style>
</head>
<body onload="init()">
<canvas id="gameCanvas"></canvas>

<script>
  // ---------- CONSTANTS ----------
  const GROUND_HEIGHT = 100;
  const PLAYER_WIDTH = 48;
  const PLAYER_HEIGHT = 56;
  const PLAYER_SLIDE_HEIGHT = 28;
  const GRAVITY = 0.55;
  const JUMP_FORCE = -14;

  const INITIAL_SPEED = 4.5;
  const MAX_SPEED = 16;
  const BASE_SPEED_INCREMENT = 0.0012;
  const COYOTE_TIME = 8;

  // Palette (watermelon / teal + parchment)
  const PALETTE = {
    seaDark: "#022c22",
    seaLight: "#0f766e",
    seaEdge: "#67e8f9",
    parchmentLight: "#fef9c3",
    parchmentMid: "#fde68a",
    parchmentDark: "#f97316",
    outlineDark: "#7c2d12",
    watermelon: "#ff5c7a",
    watermelonDark: "#be123c",
    teal: "#14b8a6",
    tealDark: "#0f766e"
  };

  // ---------- GAME STATE ----------
  const game = {
    state: "map",             // "map" | "running" | "gameover"
    player: {
      x: 120,
      y: 0,
      velocityY: 0,
      isJumping: false,
      isSliding: false,
      slideTimer: 0,
    },
    obstacles: [],
    coins: [],
    powerUps: [],
    particles: [],
    parallaxLayers: [],
    monster: { x: -150, targetX: -150, size: 1 },
    coyoteCounter: 0,
    speed: INITIAL_SPEED,
    score: 0,
    greenCoins: 0,
    redCoins: 0,
    necessityMeter: 100,
    distance: 0,
    frameCount: 0,
    groundY: 0,
    hasKestrlCard: false,
    kestrlCardTimer: 0,
    debtThreshold: -150,
    glitchIntensity: 0,
    gameOverTime: 0,
    savingsPot: 0,
  };

  let canvas, ctx;
  let animationId;

  // map hover
  let hoveredRegionId = null;

  // ---------- MAP REGIONS (5 KINGDOMS) ----------
  function getMapRegions() {
    const w = canvas.width;
    const h = canvas.height;

    const margin = Math.min(w, h) * 0.08;
    const x = margin;
    const y = margin * 1.1;
    const mapW = w - margin * 2;
    const mapH = h - margin * 2.2;

    // helper to place regions as percentage of island
    const px = f => x + mapW * f;
    const py = f => y + mapH * f;
    const baseR = Math.max(30, Math.min(w, h) * 0.035);

    return [
      {
        id: "qard",
        name: "QARD VALLEY",
        subtitle: "Student Debt Ravine",
        status: "locked",
        cx: px(0.22),
        cy: py(0.30),
        r: baseR
      },
      {
        id: "bayt",
        name: "BAYT AL-TIJARA",
        subtitle: "Consumer Credit Bazaar",
        status: "locked",
        cx: px(0.40),
        cy: py(0.42),
        r: baseR
      },
      {
        id: "riba",
        name: "KINGDOM OF SYARMIN",
        subtitle: "Riba Market",
        status: "unlocked",
        cx: px(0.58),
        cy: py(0.54),
        r: baseR * 1.15
      },
      {
        id: "sukuk",
        name: "SUKUK SANDS",
        subtitle: "Speculation Dunes",
        status: "locked",
        cx: px(0.76),
        cy: py(0.42),
        r: baseR
      },
      {
        id: "takaful",
        name: "TAKAFUL ISLES",
        subtitle: "Shared Risk Archipelago",
        status: "locked",
        cx: px(0.70),
        cy: py(0.72),
        r: baseR
      },
    ];
  }

  function pointInRegion(x, y, region) {
    const dx = x - region.cx;
    const dy = y - region.cy;
    return dx * dx + dy * dy <= region.r * region.r * 1.5;
  }

  function handleMapClick(x, y) {
    const regions = getMapRegions();
    for (const region of regions) {
      if (pointInRegion(x, y, region)) {
        if (region.id === "riba" && region.status === "unlocked") {
          startRibaRun();
        }
        return;
      }
    }
  }

  function handleMapHover(x, y) {
    const regions = getMapRegions();
    hoveredRegionId = null;
    for (const region of regions) {
      if (region.status === "unlocked" && pointInRegion(x, y, region)) {
        hoveredRegionId = region.id;
        break;
      }
    }
  }

  function startRibaRun() {
    resetRun();
  }

  // ---------- INIT ----------
  function init() {
    canvas = document.getElementById("gameCanvas");
    ctx = canvas.getContext("2d");

    try {
      const saved = localStorage.getItem("ribaRunSavings");
      if (saved !== null) game.savingsPot = parseInt(saved, 10) || 0;
    } catch (e) {
      game.savingsPot = 0;
    }

    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    window.addEventListener("keydown", handleKeyDown);
    canvas.addEventListener("touchstart", handleTouch, { passive: false });
    canvas.addEventListener("click", handleClick);
    canvas.addEventListener("mousemove", handleMouseMove);

    gameLoop();
  }

  function resetRun() {
    game.state = "running";
    game.obstacles = [];
    game.coins = [];
    game.powerUps = [];
    game.particles = [];
    game.parallaxLayers = [
      { x: 0, speed: 0.2 },
      { x: 0, speed: 0.4 },
      { x: 0, speed: 0.6 },
    ];

    game.monster = { x: -150, targetX: -150, size: 1 };
    game.coyoteCounter = 0;
    game.speed = INITIAL_SPEED;
    game.score = 0;
    game.greenCoins = 0;
    game.redCoins = 0;
    game.necessityMeter = 100;
    game.distance = 0;
    game.frameCount = 0;
    game.hasKestrlCard = false;
    game.kestrlCardTimer = 0;
    game.glitchIntensity = 0;
    game.gameOverTime = 0;

    game.player.x = 120;
    game.player.y = game.groundY - PLAYER_HEIGHT;
    game.player.velocityY = 0;
    game.player.isJumping = false;
    game.player.isSliding = false;
    game.player.slideTimer = 0;
  }

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    game.groundY = canvas.height - GROUND_HEIGHT;
    if (game.state === "running") {
      game.player.y = game.groundY - PLAYER_HEIGHT;
    }
  }

  // ---------- INPUT ----------
  function handleKeyDown(e) {
    if (game.state === "map") {
      if (e.code === "Space" || e.code === "Enter") {
        startRibaRun();
      }
      return;
    }

    if (game.state === "gameover") {
      if (e.code === "Space" || e.code === "Enter") {
        resetRun();
      }
      return;
    }

    if (e.code === "Space" || e.code === "ArrowUp") {
      e.preventDefault();
      handleJump();
    } else if (e.code === "ArrowDown") {
      e.preventDefault();
      handleSlide();
    } else if (e.code === "KeyS") {
      e.preventDefault();
      handleSave();
    }
  }

  function handleTouch(e) {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;

    if (game.state === "map") {
      handleMapClick(x, y);
      return;
    }

    if (game.state === "gameover") {
      resetRun();
      return;
    }

    if (y > window.innerHeight / 2) {
      handleSlide();
    } else {
      handleJump();
    }
  }

  function handleClick(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (game.state === "map") {
      handleMapClick(x, y);
    }
  }

  function handleMouseMove(e) {
    if (game.state !== "map") return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    handleMapHover(x, y);
  }

  function handleJump() {
    const p = game.player;
    const canJump =
      (!p.isJumping || game.coyoteCounter > 0) &&
      !p.isSliding &&
      game.state === "running";
    if (canJump) {
      p.velocityY = JUMP_FORCE;
      p.isJumping = true;
      game.coyoteCounter = 0;
    }
  }

  function handleSlide() {
    const p = game.player;
    if (!p.isJumping && !p.isSliding && game.state === "running") {
      p.isSliding = true;
      p.slideTimer = 35;
    }
  }

  function handleSave() {
    if (game.state !== "running") return;
    if (game.score >= 10) {
      game.score -= 10;
      game.savingsPot += 10;
      try {
        localStorage.setItem("ribaRunSavings", String(game.savingsPot));
      } catch (e) {}

      createParticles(
        game.player.x + PLAYER_WIDTH / 2,
        game.player.y,
        "#22c55e",
        10
      );
    }
  }

  // ---------- SPAWN HELPERS ----------
  function spawnObstacle() {
    const types = ["low", "high", "double"];
    const type = types[Math.floor(Math.random() * types.length)];

    let obstacle = { x: canvas.width + 50, type, passed: false };

    if (type === "low") {
      obstacle.y = game.groundY - 45;
      obstacle.width = 35;
      obstacle.height = 45;
    } else if (type === "high") {
      obstacle.y = game.groundY - 90;
      obstacle.width = 45;
      obstacle.height = 35;
    } else {
      obstacle.y = game.groundY - 70;
      obstacle.width = 55;
      obstacle.height = 70;
    }

    game.obstacles.push(obstacle);
  }

  function spawnCoin() {
    const spawnGreen = Math.random() < 0.6;

    if (spawnGreen) {
      const positions = [
        { y: game.groundY - 120, count: 3 },
        { y: game.groundY - 90, count: 2 },
      ];
      const pos = positions[Math.floor(Math.random() * positions.length)];
      for (let i = 0; i < pos.count; i++) {
        game.coins.push({
          x: canvas.width + 60 + i * 40,
          y: pos.y,
          radius: 16,
          isGreen: true,
          pulsePhase: Math.random() * Math.PI * 2,
        });
      }
    } else {
      const count = Math.floor(Math.random() * 2) + 1;
      for (let i = 0; i < count; i++) {
        game.coins.push({
          x: canvas.width + 60 + i * 35,
          y: game.groundY - 40,
          radius: 14,
          isGreen: false,
          pulsePhase: Math.random() * Math.PI * 2,
        });
      }
    }
  }

  function spawnKestrlCard() {
    if (
      Math.random() < 0.25 &&
      !game.hasKestrlCard &&
      game.powerUps.length === 0
    ) {
      game.powerUps.push({
        x: canvas.width + 50,
        y: game.groundY - 90,
        width: 50,
        height: 32,
        pulsePhase: 0,
      });
    }
  }

  function createParticles(x, y, color, count) {
    const n = count || 10;
    for (let i = 0; i < n; i++) {
      game.particles.push({
        x,
        y,
        vx: (Math.random() - 0.5) * 6,
        vy: (Math.random() - 0.5) * 6,
        life: 1,
        color,
        size: Math.random() * 3 + 2,
      });
    }
  }

  // ---------- DEATH / REVIVE ----------
  function triggerDeath() {
    if (game.state !== "running") return;

    const finalScore = Math.floor(game.score);
    const currentDebt = finalScore < 0 ? finalScore : 0;
    const reviveCost = 50 + Math.abs(currentDebt);

    if (game.savingsPot >= reviveCost) {
      game.savingsPot -= reviveCost;
      try {
        localStorage.setItem("ribaRunSavings", String(game.savingsPot));
      } catch (e) {}

      game.score = Math.max(0, finalScore);
      game.necessityMeter = 50;
      game.hasKestrlCard = false;
      game.kestrlCardTimer = 0;
      game.glitchIntensity = 0;

      game.monster.x = -260;
      game.monster.targetX = -260;
      game.monster.size = 1;

      createParticles(
        game.player.x + PLAYER_WIDTH / 2,
        game.player.y,
        "#22c55e",
        25
      );
    } else {
      game.state = "gameover";
      game.gameOverTime = 0;
    }
  }

  // ---------- UPDATE ----------
  function update() {
    if (game.state === "map") {
      game.frameCount++;
      return;
    }

    if (game.state !== "running") {
      if (game.state === "gameover") game.gameOverTime++;
      return;
    }

    game.frameCount++;
    game.distance = Math.floor((game.frameCount * game.speed) / 15);

    const distanceFactor = Math.min(game.distance / 800, 1.5);
    const targetSpeed = Math.min(INITIAL_SPEED + distanceFactor * 6, MAX_SPEED);
    if (game.speed < targetSpeed) {
      game.speed += BASE_SPEED_INCREMENT * (1 + distanceFactor);
    }

    if (game.hasKestrlCard) {
      game.kestrlCardTimer--;
      if (game.kestrlCardTimer <= 0) {
        game.hasKestrlCard = false;
      }
    }

    game.necessityMeter = Math.max(0, game.necessityMeter - 0.03);
    if (game.necessityMeter <= 0) {
      game.score -= 0.5;
    }

    game.parallaxLayers.forEach((layer) => {
      layer.x -= game.speed * layer.speed;
      if (layer.x <= -canvas.width) layer.x += canvas.width;
    });

    const p = game.player;

    if (p.isSliding) {
      p.slideTimer--;
      if (p.slideTimer <= 0) p.isSliding = false;
    }

    p.velocityY += GRAVITY;
    p.y += p.velocityY;

    const playerHeight = p.isSliding ? PLAYER_SLIDE_HEIGHT : PLAYER_HEIGHT;
    if (p.y >= game.groundY - playerHeight) {
      p.y = game.groundY - playerHeight;
      p.velocityY = 0;
      p.isJumping = false;
      game.coyoteCounter = COYOTE_TIME;
    } else if (game.coyoteCounter > 0) {
      game.coyoteCounter--;
    }

    const monsterBaseX = -150;
    if (game.score < 0) {
      const debt = Math.abs(game.score);
      game.monster.targetX = monsterBaseX + Math.min(debt * 1.5, p.x - 80);
      game.monster.size = 1 + Math.min(debt / 200, 1.5);
    } else {
      game.monster.targetX = monsterBaseX;
      game.monster.size = Math.max(1, game.monster.size - 0.01);
    }

    if (game.hasKestrlCard) {
      game.monster.targetX = monsterBaseX - 150;
    }

    game.monster.x += (game.monster.targetX - game.monster.x) * 0.05;

    if (game.score < game.debtThreshold) {
      const excessDebt = Math.abs(game.score) - Math.abs(game.debtThreshold);
      game.glitchIntensity = Math.min(1, excessDebt / 200);
    } else {
      game.glitchIntensity = Math.max(0, game.glitchIntensity - 0.02);
    }

    if (game.monster.x + 40 >= p.x) {
      createParticles(
        p.x + PLAYER_WIDTH / 2,
        p.y + PLAYER_HEIGHT / 2,
        "#ef4444",
        25
      );
      triggerDeath();
    }

    if (game.frameCount % Math.max(60, 130 - Math.floor(game.speed * 3)) === 0) {
      spawnObstacle();
    }
    if (game.frameCount % 50 === 0) spawnCoin();
    if (game.frameCount % 120 === 0) spawnKestrlCard();

    game.obstacles = game.obstacles.filter((obs) => {
      obs.x -= game.speed;

      const playerBox = {
        x: p.x,
        y: p.y,
        width: PLAYER_WIDTH - 10,
        height: playerHeight,
      };

      if (
        playerBox.x < obs.x + obs.width - 5 &&
        playerBox.x + playerBox.width > obs.x + 5 &&
        playerBox.y < obs.y + obs.height &&
        playerBox.y + playerBox.height > obs.y
      ) {
        createParticles(
          p.x + PLAYER_WIDTH / 2,
          p.y + PLAYER_HEIGHT / 2,
          "#ef4444",
          20
        );
        triggerDeath();
      }

      if (!obs.passed && obs.x + obs.width < p.x) {
        obs.passed = true;
        game.score += 5;
      }

      return obs.x > -100;
    });

    game.coins = game.coins.filter((coin) => {
      coin.x -= game.speed;
      coin.pulsePhase += 0.1;

      const centerX = p.x + PLAYER_WIDTH / 2;
      const centerY = p.y + playerHeight / 2;
      const dx = coin.x - centerX;
      const dy = coin.y - centerY;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < coin.radius + 28) {
        if (game.hasKestrlCard) {
          game.score += 10;
          game.necessityMeter = Math.min(100, game.necessityMeter + 8);
          createParticles(coin.x, coin.y, "#06b6d4", 10);
        } else if (coin.isGreen) {
          game.greenCoins++;
          game.score += 10;
          game.necessityMeter = Math.min(100, game.necessityMeter + 12);
          createParticles(coin.x, coin.y, "#22c55e", 10);
        } else {
          game.redCoins++;
          game.score -= 50;
          game.necessityMeter = Math.min(100, game.necessityMeter + 5);
          createParticles(coin.x, coin.y, "#ef4444", 10);
          game.glitchIntensity = Math.min(1, game.glitchIntensity + 0.18);
        }
        return false;
      }

      return coin.x > -40;
    });

    game.powerUps = game.powerUps.filter((pu) => {
      pu.x -= game.speed;
      pu.pulsePhase += 0.12;

      const centerX = p.x + PLAYER_WIDTH / 2;
      const centerY = p.y + playerHeight / 2;
      if (
        centerX > pu.x - 20 &&
        centerX < pu.x + pu.width + 20 &&
        centerY > pu.y - 20 &&
        centerY < pu.y + pu.height + 20
      ) {
        game.hasKestrlCard = true;
        game.kestrlCardTimer = 600;
        createParticles(
          pu.x + pu.width / 2,
          pu.y + pu.height / 2,
          "#06b6d4",
          20
        );
        game.monster.x = -260;
        game.monster.targetX = -260;
        return false;
      }

      return pu.x > -100;
    });

    game.particles = game.particles.filter((p2) => {
      p2.x += p2.vx;
      p2.y += p2.vy;
      p2.life -= 0.03;
      return p2.life > 0;
    });

    if (!p.isJumping && !p.isSliding && game.frameCount % 8 === 0) {
      game.particles.push({
        x: p.x,
        y: game.groundY - 4,
        vx: -2,
        vy: -1,
        life: 0.5,
        color: "#facc15",
        size: 3,
      });
    }
  }

  // ---------- DRAW PIXEL MONSTER ----------
  function drawPixelMonster() {
    const m = game.monster;
    const intensity =
      game.score < 0 ? Math.min(1, Math.abs(game.score) / 200) : 0;

    const pixel = 4;
    const baseSize = 10;

    ctx.save();
    ctx.translate(m.x + 40 * m.size, game.groundY - 70 * m.size);
    ctx.scale(m.size, m.size);

    const radius = baseSize * pixel * 1.6;
    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
    gradient.addColorStop(0, "rgba(15,23,42,0.9)");
    gradient.addColorStop(0.6, `rgba(127,29,29,${0.5 + intensity * 0.4})`);
    gradient.addColorStop(1, "rgba(15,23,42,0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(0, 0, radius, 0, Math.PI * 2);
    ctx.fill();

    const drawBlock = (x, y, w, h, color) => {
      ctx.fillStyle = color;
      ctx.fillRect(x * pixel, y * pixel, w * pixel, h * pixel);
    };

    const bodyCol = "#111827";
    const highlightCol = "#1f2937";

    for (let row = -6; row <= 6; row++) {
      const width = row < 0 ? 6 + row : 6 - row * 0.7;
      for (let col = -width; col <= width; col++) {
        const c = Math.random() > 0.75 ? highlightCol : bodyCol;
        drawBlock(col, row, 1, 1, c);
      }
    }

    drawBlock(-5, -7, 2, 3, "#000000");
    drawBlock(3, -7, 2, 3, "#000000");

    ctx.shadowColor = "#f97316";
    ctx.shadowBlur = 12 + intensity * 12;
    drawBlock(-3, -3, 2, 2, "#f97316");
    drawBlock(2, -3, 2, 2, "#f97316");
    ctx.shadowBlur = 0;

    drawBlock(-2, -2, 1, 1, "#ffffff");
    drawBlock(3, -2, 1, 1, "#ffffff");

    for (let i = -3; i <= 3; i++) {
      const h = i % 2 === 0 ? 2 : 1;
      drawBlock(i, 2, 1, h, "#ef4444");
    }

    ctx.restore();
  }

  // ---------- DRAW PIXEL KESTREL ----------
  function drawPixelPlayer() {
    const p = game.player;
    const height = p.isSliding ? PLAYER_SLIDE_HEIGHT : PLAYER_HEIGHT;
    const pixel = 4;

    ctx.save();
    ctx.translate(p.x + PLAYER_WIDTH / 2, p.y + height / 2);

    if (p.isSliding) {
      ctx.rotate(-Math.PI / 12);
      ctx.scale(1.1, 0.7);
    }

    if (game.hasKestrlCard) {
      ctx.shadowColor = "#22c55e";
      ctx.shadowBlur = 18;
    }

    const runFrame = Math.floor(game.frameCount / 6) % 4;
    const wingFrame = p.isJumping ? 2 : runFrame;
    const legOffset = [0, -1, 0, 1][runFrame];

    const cols = {
      bodyDark: "#5c3d2e",
      bodyMid: "#8b5e3c",
      bodyLight: "#a67c52",
      wingDark: "#4a2d1a",
      wingMid: "#6b4423",
      head: "#0ea5e9",
      beak: game.hasKestrlCard ? "#22c55e" : "#eab308",
      beakLight: game.hasKestrlCard ? "#86efac" : "#facc15",
      eye: "#000000",
      eyeShine: "#ffffff",
      outline: "#111827",
    };

    const drawPx = (x, y, w, h, color) => {
      ctx.fillStyle = color;
      ctx.fillRect(x * pixel, y * pixel, w * pixel, h * pixel);
    };

    drawPx(-6, -6, 13, 11, cols.outline);

    drawPx(-5, -5, 11, 9, cols.bodyMid);
    drawPx(-5, -5, 9, 3, cols.bodyLight);
    drawPx(-5, 1, 11, 3, cols.bodyDark);

    const wingY = [-3, -4, -5, -4][wingFrame];
    drawPx(-4, wingY, 6, 4, cols.wingDark);
    drawPx(-3, wingY, 4, 2, cols.wingMid);

    drawPx(4, -7, 6, 6, cols.head);
    drawPx(4, -7, 5, 2, "#38bdf8");

    drawPx(7, -6, 2, 2, cols.eye);
    drawPx(8, -6, 1, 1, cols.eyeShine);

    drawPx(10, -5, 3, 1, cols.beak);
    drawPx(11, -4, 2, 1, cols.beakLight);

    drawPx(-7, -1, 2, 1, cols.wingMid);
    drawPx(-8, 0, 2, 1, cols.wingDark);
    drawPx(-9, 1, 2, 1, cols.wingMid);

    if (!p.isSliding) {
      const leg1Y = 3 + legOffset;
      const leg2Y = 3 - legOffset;
      drawPx(-1, leg1Y, 1, 3, cols.beak);
      drawPx(2, leg2Y, 1, 3, cols.beak);
    }

    ctx.shadowBlur = 0;
    ctx.restore();
  }

  // ---------- DRAW FANTASY WORLD MAP ----------
  function drawWorldMap() {
    const w = canvas.width;
    const h = canvas.height;

    ctx.save();
    ctx.imageSmoothingEnabled = false;

    // Sea background with subtle vertical shimmer
    const seaGrad = ctx.createLinearGradient(0, 0, 0, h);
    seaGrad.addColorStop(0, PALETTE.seaLight);
    seaGrad.addColorStop(1, PALETTE.seaDark);
    ctx.fillStyle = seaGrad;
    ctx.fillRect(0, 0, w, h);

    // animated water stripes
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = PALETTE.seaEdge;
    const stripeOffset = (game.frameCount * 0.7) % 40;
    for (let i = -40; i < h + 40; i += 40) {
      ctx.fillRect(0, i + stripeOffset, w, 2);
    }
    ctx.globalAlpha = 1;

    const margin = Math.min(w, h) * 0.08;
    const x = margin;
    const y = margin * 1.1;
    const mapW = w - margin * 2;
    const mapH = h - margin * 2.2;

    // parchment frame
    const parchment = ctx.createLinearGradient(0, y, 0, y + mapH);
    parchment.addColorStop(0, PALETTE.parchmentLight);
    parchment.addColorStop(0.5, PALETTE.parchmentMid);
    parchment.addColorStop(1, "#facc15");
    ctx.fillStyle = parchment;
    ctx.fillRect(x, y, mapW, mapH);

    ctx.strokeStyle = PALETTE.outlineDark;
    ctx.lineWidth = 6;
    ctx.strokeRect(x, y, mapW, mapH);

    ctx.strokeStyle = "rgba(0,0,0,0.25)";
    ctx.lineWidth = 2;
    ctx.strokeRect(x + 10, y + 10, mapW - 20, mapH - 20);

    // title
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillStyle = "#111827";
    ctx.font = "bold 40px 'Courier New', monospace";
    ctx.fillText("HALAL REALM", w / 2, y + 12);

    ctx.font = "16px 'Courier New', monospace";
    ctx.fillStyle = "#374151";
    ctx.fillText(
      "Click a kingdom to cleanse its markets.",
      w / 2,
      y + 56
    );

    ctx.font = "14px 'Courier New', monospace";
    ctx.fillStyle = "#4b5563";
    ctx.fillText(
      "Begin in the Kingdom of Syarmin and confront Riba.",
      w / 2,
      y + 80
    );

    // main island shape
    const islandX = x + mapW * 0.06;
    const islandY = y + mapH * 0.16;
    const islandW = mapW * 0.88;
    const islandH = mapH * 0.68;

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(islandX + islandW * 0.12, islandY + islandH * 0.15);
    ctx.bezierCurveTo(
      islandX + islandW * 0.00, islandY + islandH * 0.40,
      islandX + islandW * 0.10, islandY + islandH * 0.70,
      islandX + islandW * 0.26, islandY + islandH * 0.85
    );
    ctx.bezierCurveTo(
      islandX + islandW * 0.55, islandY + islandH * 1.05,
      islandX + islandW * 0.90, islandY + islandH * 0.90,
      islandX + islandW * 0.92, islandY + islandH * 0.55
    );
    ctx.bezierCurveTo(
      islandX + islandW * 0.95, islandY + islandH * 0.25,
      islandX + islandW * 0.70, islandY + islandH * 0.04,
      islandX + islandW * 0.40, islandY + islandH * 0.10
    );
    ctx.bezierCurveTo(
      islandX + islandW * 0.25, islandY + islandH * 0.12,
      islandX + islandW * 0.15, islandY + islandH * 0.10,
      islandX + islandW * 0.12, islandY + islandH * 0.15
    );
    ctx.closePath();

    const landGrad = ctx.createLinearGradient(islandX, islandY, islandX, islandY + islandH);
    landGrad.addColorStop(0, "#e5e7eb");
    landGrad.addColorStop(0.35, "#bbf7d0");
    landGrad.addColorStop(0.6, "#a5f3fc");
    landGrad.addColorStop(1, "#fed7aa");
    ctx.fillStyle = landGrad;
    ctx.fill();
    ctx.strokeStyle = "#0f172a";
    ctx.lineWidth = 2;
    ctx.stroke();

    // biomes: mountains (top), plains (centre), desert (right), jungle (bottom left)
    // mountains
    ctx.fillStyle = "#e5e7eb";
    ctx.beginPath();
    ctx.moveTo(islandX + islandW * 0.18, islandY + islandH * 0.18);
    ctx.lineTo(islandX + islandW * 0.28, islandY + islandH * 0.08);
    ctx.lineTo(islandX + islandW * 0.38, islandY + islandH * 0.19);
    ctx.lineTo(islandX + islandW * 0.48, islandY + islandH * 0.09);
    ctx.lineTo(islandX + islandW * 0.58, islandY + islandH * 0.20);
    ctx.lineTo(islandX + islandW * 0.70, islandY + islandH * 0.11);
    ctx.lineTo(islandX + islandW * 0.82, islandY + islandH * 0.23);
    ctx.lineTo(islandX + islandW * 0.65, islandY + islandH * 0.28);
    ctx.lineTo(islandX + islandW * 0.30, islandY + islandH * 0.28);
    ctx.closePath();
    ctx.fill();

    // desert
    ctx.fillStyle = "#fed7aa";
    ctx.beginPath();
    ctx.moveTo(islandX + islandW * 0.55, islandY + islandH * 0.30);
    ctx.lineTo(islandX + islandW * 0.90, islandY + islandH * 0.38);
    ctx.lineTo(islandX + islandW * 0.86, islandY + islandH * 0.70);
    ctx.lineTo(islandX + islandW * 0.60, islandY + islandH * 0.65);
    ctx.closePath();
    ctx.fill();

    // jungle
    ctx.fillStyle = "#064e3b";
    ctx.beginPath();
    ctx.moveTo(islandX + islandW * 0.12, islandY + islandH * 0.55);
    ctx.lineTo(islandX + islandW * 0.38, islandY + islandH * 0.60);
    ctx.lineTo(islandX + islandW * 0.30, islandY + islandH * 0.88);
    ctx.lineTo(islandX + islandW * 0.10, islandY + islandH * 0.80);
    ctx.closePath();
    ctx.fill();

    // rivers
    ctx.strokeStyle = "#22d3ee";
    ctx.lineWidth = 4;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(islandX + islandW * 0.48, islandY + islandH * 0.20);
    ctx.bezierCurveTo(
      islandX + islandW * 0.44, islandY + islandH * 0.32,
      islandX + islandW * 0.43, islandY + islandH * 0.45,
      islandX + islandW * 0.41, islandY + islandH * 0.58
    );
    ctx.bezierCurveTo(
      islandX + islandW * 0.38, islandY + islandH * 0.77,
      islandX + islandW * 0.30, islandY + islandH * 0.86,
      islandX + islandW * 0.20, islandY + islandH * 0.90
    );
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(islandX + islandW * 0.48, islandY + islandH * 0.22);
    ctx.bezierCurveTo(
      islandX + islandW * 0.54, islandY + islandH * 0.32,
      islandX + islandW * 0.62, islandY + islandH * 0.42,
      islandX + islandW * 0.70, islandY + islandH * 0.55
    );
    ctx.stroke();
    ctx.restore();

    // tiny pixel trees & mountains for Mario vibe
    ctx.save();
    const drawTree = (cx, cy) => {
      ctx.fillStyle = "#065f46";
      ctx.fillRect(cx - 2, cy, 4, 8);
      ctx.beginPath();
      ctx.arc(cx, cy, 6, 0, Math.PI * 2);
      ctx.fillStyle = "#10b981";
      ctx.fill();
    };
    const drawMiniMountain = (cx, cy) => {
      ctx.fillStyle = "#9ca3af";
      ctx.beginPath();
      ctx.moveTo(cx, cy - 10);
      ctx.lineTo(cx - 8, cy + 6);
      ctx.lineTo(cx + 8, cy + 6);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = "#6b7280";
      ctx.beginPath();
      ctx.moveTo(cx, cy - 10);
      ctx.lineTo(cx - 4, cy);
      ctx.lineTo(cx, cy);
      ctx.closePath();
      ctx.fill();
    };

    for (let i = 0; i < 18; i++) {
      const tx = islandX + islandW * (0.14 + (i % 6) * 0.06);
      const ty = islandY + islandH * (0.58 + Math.floor(i / 6) * 0.08);
      drawTree(tx, ty);
    }
    for (let i = 0; i < 14; i++) {
      const mx = islandX + islandW * (0.18 + i * 0.04);
      const my = islandY + islandH * (0.24 + (i % 2) * 0.03);
      drawMiniMountain(mx, my);
    }

    // animated clouds above island
    const cloudY = y + mapH * 0.08;
    const cloudSpeed = 0.3;
    ctx.fillStyle = "rgba(248,250,252,0.9)";
    for (let i = 0; i < 4; i++) {
      const cxBase = (i * 220 + game.frameCount * cloudSpeed) % (mapW + 200);
      const cxCloud = x + cxBase - 100;
      ctx.beginPath();
      ctx.arc(cxCloud, cloudY, 26, 0, Math.PI * 2);
      ctx.arc(cxCloud + 24, cloudY + 6, 22, 0, Math.PI * 2);
      ctx.arc(cxCloud - 24, cloudY + 6, 20, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();

    // Qibla / compass top-right
    ctx.save();
    const compassR = Math.min(w, h) * 0.055;
    const cxCompass = x + mapW - compassR - 24;
    const cyCompass = y + compassR + 18;

    const compGrad = ctx.createRadialGradient(
      cxCompass, cyCompass, compassR * 0.2,
      cxCompass, cyCompass, compassR
    );
    compGrad.addColorStop(0, "#fee2e2");
    compGrad.addColorStop(1, PALETTE.watermelon);
    ctx.fillStyle = compGrad;
    ctx.beginPath();
    ctx.arc(cxCompass, cyCompass, compassR, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = PALETTE.outlineDark;
    ctx.lineWidth = 3;
    ctx.stroke();

    ctx.strokeStyle = "#7f1d1d";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cxCompass - compassR * 0.7, cyCompass);
    ctx.lineTo(cxCompass + compassR * 0.7, cyCompass);
    ctx.moveTo(cxCompass, cyCompass - compassR * 0.7);
    ctx.lineTo(cxCompass, cyCompass + compassR * 0.7);
    ctx.stroke();

    ctx.fillStyle = "#111827";
    ctx.font = "12px 'Courier New', monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("QIBLA", cxCompass, cyCompass + compassR * 0.55);
    ctx.restore();

    // LEVEL NODES + PATH
    const regions = getMapRegions();

    // draw connecting path (Mario-style) from qard -> bayt -> syarmin -> sukuk -> takaful
    const pathPoints = regions.map(r => ({ x: r.cx, y: r.cy }));
    ctx.save();
    ctx.strokeStyle = "rgba(15,23,42,0.7)";
    ctx.lineWidth = 5;
    ctx.setLineDash([14, 10]);
    ctx.lineDashOffset = -game.frameCount * 0.6;
    ctx.beginPath();
    for (let i = 0; i < pathPoints.length; i++) {
      const pt = pathPoints[i];
      if (i === 0) ctx.moveTo(pt.x, pt.y);
      else ctx.lineTo(pt.x, pt.y);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    // glowing overlay path for unlocked chain (currently only up to Syarmin)
    ctx.strokeStyle = "rgba(56,189,248,0.6)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    for (let i = 0; i <= 2; i++) {  // qard -> bayt -> syarmin segment
      const pt = pathPoints[i];
      if (i === 0) ctx.moveTo(pt.x, pt.y);
      else ctx.lineTo(pt.x, pt.y);
    }
    ctx.stroke();
    ctx.restore();

    // draw each kingdom node
    ctx.save();
    regions.forEach(region => {
      const unlocked = region.status === "unlocked";
      const isHover = unlocked && region.id === hoveredRegionId;
      const pulse = Math.sin(game.frameCount * 0.08) * (unlocked ? 4 : 1);
      const r = region.r + (unlocked ? 4 : 0) + (isHover ? 3 : 0);

      // glow for unlocked
      if (unlocked) {
        const glowR = r * 2;
        const glow = ctx.createRadialGradient(
          region.cx, region.cy, 0,
          region.cx, region.cy, glowR
        );
        glow.addColorStop(0, "rgba(52,211,153,0.9)");
        glow.addColorStop(1, "rgba(16,185,129,0)");
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.arc(region.cx, region.cy, glowR, 0, Math.PI * 2);
        ctx.fill();
      }

      // base circle
      const circleGrad = ctx.createLinearGradient(
        region.cx, region.cy - r, region.cx, region.cy + r
      );
      if (unlocked) {
        circleGrad.addColorStop(0, "#fef3c7");
        circleGrad.addColorStop(1, "#22c55e");
      } else {
        circleGrad.addColorStop(0, "#e5e7eb");
        circleGrad.addColorStop(1, "#9ca3af");
      }
      ctx.fillStyle = circleGrad;
      ctx.beginPath();
      ctx.arc(region.cx, region.cy, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = unlocked ? "#064e3b" : "#4b5563";
      ctx.lineWidth = 3;
      ctx.stroke();

      // flagpole-style arrow
      ctx.fillStyle = unlocked ? PALETTE.watermelonDark : "#6b7280";
      const poleH = r * 0.9;
      ctx.fillRect(region.cx - 6, region.cy - poleH * 0.7, 12, poleH * 0.7);
      ctx.beginPath();
      ctx.moveTo(region.cx - 10, region.cy - poleH * 0.7);
      ctx.lineTo(region.cx, region.cy - poleH);
      ctx.lineTo(region.cx + 10, region.cy - poleH * 0.7);
      ctx.closePath();
      ctx.fill();

      // lock icon for locked regions
      if (!unlocked) {
        const lockR = r * 0.38;
        ctx.fillStyle = "#020617";
        ctx.beginPath();
        ctx.roundRect(region.cx - lockR, region.cy - lockR * 0.5, lockR * 2, lockR * 1.4, 6);
        ctx.fill();
        ctx.fillStyle = "#e5e7eb";
        ctx.fillRect(region.cx - lockR * 0.55, region.cy - lockR * 0.1, lockR * 1.1, lockR * 0.45);
        ctx.beginPath();
        ctx.arc(region.cx, region.cy - lockR * 0.2, lockR * 0.7, Math.PI, 0);
        ctx.strokeStyle = "#e5e7eb";
        ctx.lineWidth = 2;
        ctx.stroke();
      } else {
        // sparkles around syarmin
        for (let i = 0; i < 8; i++) {
          const angle = (Math.PI * 2 * i) / 8 + game.frameCount * 0.05;
          const dist = r * 1.6;
          const sx = region.cx + Math.cos(angle) * dist;
          const sy = region.cy + Math.sin(angle) * dist;
          ctx.fillStyle = "rgba(250,250,250,0.9)";
          ctx.fillRect(sx - 1, sy - 1, 2, 2);
        }
      }

      // label panel
      const panelY = region.cy + r + 12;
      const panelW = Math.max(260, region.name.length * 11);
      ctx.fillStyle = "#020617";
      ctx.fillRect(region.cx - panelW / 2, panelY, panelW, 54);
      ctx.strokeStyle = unlocked ? PALETTE.teal : "#4b5563";
      ctx.lineWidth = 2;
      ctx.strokeRect(region.cx - panelW / 2, panelY, panelW, 54);

      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.font = "16px 'Courier New', monospace";
      ctx.fillStyle = "#e5e7eb";
      ctx.fillText(region.name, region.cx, panelY + 4);

      ctx.font = "13px 'Courier New', monospace";
      ctx.fillStyle = "#9ca3af";
      ctx.fillText(region.subtitle, region.cx, panelY + 22);

      if (unlocked) {
        ctx.fillStyle = "#bbf7d0";
        ctx.fillText("CLICK TO ENTER", region.cx, panelY + 36);
      } else {
        ctx.fillStyle = "#fecaca";
        ctx.fillText("LOCKED · Coming soon", region.cx, panelY + 36);
      }
    });
    ctx.restore();

    // tip text
    ctx.save();
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.font = "14px 'Courier New', monospace";
    ctx.fillStyle = "#4b5563";
    ctx.fillText(
      "Tip: Press SPACE or ENTER to jump straight into the Kingdom of Syarmin",
      w / 2,
      y + mapH - 8
    );
    ctx.restore();
  }

  // ---------- DRAW MAIN GAME ----------
  function draw() {
    ctx.save();
    ctx.imageSmoothingEnabled = false;

    if (game.state === "map") {
      drawWorldMap();
      ctx.restore();
      return;
    }

    if (game.glitchIntensity > 0.25) {
      const s = game.glitchIntensity * 5;
      ctx.translate(
        (Math.random() - 0.5) * s,
        (Math.random() - 0.5) * s
      );
    }

    const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
    sky.addColorStop(0, "#5c94fc");
    sky.addColorStop(1, "#1e40af");
    ctx.fillStyle = sky;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "#eff6ff";
    for (let i = 0; i < 40; i++) {
      const x = (i * 173 + game.frameCount * 0.1) % canvas.width;
      const y = (i * 97) % (game.groundY - 60);
      ctx.fillRect(Math.floor(x), Math.floor(y), 1, 1);
    }

    ctx.fillStyle = "#1e3a8a";
    ctx.beginPath();
    ctx.moveTo(0, canvas.height);
    ctx.lineTo(canvas.width * 0.25, game.groundY - 40);
    ctx.lineTo(canvas.width * 0.5, canvas.height);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "#1d4ed8";
    ctx.beginPath();
    ctx.moveTo(canvas.width * 0.4, canvas.height);
    ctx.lineTo(canvas.width * 0.7, game.groundY - 50);
    ctx.lineTo(canvas.width, canvas.height);
    ctx.closePath();
    ctx.fill();

    const tile = 32;
    for (let x = 0; x < canvas.width + tile; x += tile) {
      ctx.fillStyle = "#f97316";
      ctx.fillRect(x, game.groundY, tile, 16);
      ctx.fillStyle = "#ea580c";
      ctx.fillRect(x, game.groundY + 16, tile, 16);
      ctx.fillStyle = "#9a3412";
      ctx.fillRect(x, game.groundY + 32, tile, GROUND_HEIGHT - 32);

      ctx.strokeStyle = "#7c2d12";
      ctx.lineWidth = 2;
      ctx.strokeRect(x, game.groundY, tile, GROUND_HEIGHT);
    }

    if (game.monster.x < canvas.width + 200) {
      drawPixelMonster();
    }

    game.obstacles.forEach((obs) => {
      ctx.fillStyle = "#6d28d9";
      ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
      ctx.strokeStyle = "#4c1d95";
      ctx.lineWidth = 2;
      ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);
    });

    game.powerUps.forEach((pu) => {
      const t = Math.sin(pu.pulsePhase) * 1.5;
      ctx.save();
      ctx.translate(pu.x + pu.width / 2, pu.y + pu.height / 2);

      const w = pu.width + t * 2;
      const h = pu.height;

      const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, w);
      glow.addColorStop(0, "rgba(56,189,248,0.8)");
      glow.addColorStop(1, "rgba(56,189,248,0)");
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(0, 0, w, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#0ea5e9";
      ctx.fillRect(-w / 2, -h / 2, w, h);
      ctx.strokeStyle = "#38bdf8";
      ctx.lineWidth = 3;
      ctx.strokeRect(-w / 2, -h / 2, w, h);

      ctx.fillStyle = "#e5e7eb";
      ctx.font = "bold 16px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("K", 0, 0);

      ctx.restore();
    });

    game.coins.forEach((coin) => {
      const px = 4;
      const baseSize = 4;
      const pulse = Math.sin(coin.pulsePhase) * 0.5;
      const s = baseSize + pulse;

      const glowRadius = s * px * 3;
      const glow = ctx.createRadialGradient(
        coin.x,
        coin.y,
        0,
        coin.x,
        coin.y,
        glowRadius
      );
      if (game.hasKestrlCard) {
        glow.addColorStop(0, "rgba(45,212,191,0.8)");
        glow.addColorStop(1, "rgba(45,212,191,0)");
      } else if (coin.isGreen) {
        glow.addColorStop(0, "rgba(250,204,21,0.8)");
        glow.addColorStop(1, "rgba(250,204,21,0)");
      } else {
        glow.addColorStop(0, "rgba(248,113,113,0.8)");
        glow.addColorStop(1, "rgba(248,113,113,0)");
      }
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(coin.x, coin.y, glowRadius, 0, Math.PI * 2);
      ctx.fill();

      const sizePx = s * px;
      const x = Math.round(coin.x - sizePx / 2);
      const y = Math.round(coin.y - sizePx / 2);

      ctx.fillStyle = game.hasKestrlCard
        ? "#22c55e"
        : coin.isGreen
        ? "#facc15"
        : "#ef4444";
      ctx.fillRect(x, y, sizePx, sizePx);

      ctx.strokeStyle = coin.isGreen ? "#92400e" : "#7f1d1d";
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, sizePx, sizePx);

      ctx.fillStyle = "#111827";
      ctx.font = "bold 12px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(coin.isGreen ? "$" : "!", coin.x, coin.y);

      ctx.font = "12px monospace";
      if (game.hasKestrlCard || coin.isGreen) {
        ctx.fillStyle = "#bbf7d0";
        ctx.fillText("+10", coin.x, coin.y + sizePx / 2 + 12);
      } else {
        ctx.fillStyle = "#fecaca";
        ctx.fillText("-50", coin.x, coin.y + sizePx / 2 + 12);
      }
    });

    drawPixelPlayer();

    game.particles.forEach((p2) => {
      ctx.globalAlpha = p2.life;
      ctx.fillStyle = p2.color;
      ctx.fillRect(
        Math.floor(p2.x),
        Math.floor(p2.y),
        Math.max(2, p2.size),
        Math.max(2, p2.size)
      );
    });
    ctx.globalAlpha = 1;

    if (game.glitchIntensity > 0) {
      const t = game.glitchIntensity;
      ctx.fillStyle = `rgba(148,27,27,${0.2 * t})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < canvas.height; y += 3) {
        ctx.fillStyle = `rgba(0,0,0,${0.1 + 0.15 * t})`;
        ctx.fillRect(0, y, canvas.width, 1);
      }

      const noiseCount = 40 * t;
      for (let i = 0; i < noiseCount; i++) {
        const nx = Math.random() * canvas.width;
        const ny = Math.random() * canvas.height;
        ctx.fillStyle =
          Math.random() > 0.5
            ? "rgba(220,38,38,0.8)"
            : "rgba(15,23,42,0.8)";
        ctx.fillRect(nx, ny, 2, 2);
      }
    }

    drawHUD();

    ctx.restore();
  }

  // ---------- HUD ----------
  function drawHUD() {
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.font = "16px monospace";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";

    ctx.fillStyle = "#020617";
    ctx.fillRect(16, 16, 160, 46);
    ctx.strokeStyle = game.score >= 0 ? "#facc15" : "#ef4444";
    ctx.lineWidth = 3;
    ctx.strokeRect(16, 16, 160, 46);
    ctx.fillStyle = "#9ca3af";
    ctx.fillText("SCORE", 24, 22);
    ctx.fillStyle = game.score >= 0 ? "#facc15" : "#f97316";
    ctx.font = "bold 20px monospace";
    ctx.fillText(Math.floor(game.score).toString(), 24, 38);

    ctx.font = "16px monospace";
    ctx.fillStyle = "#020617";
    ctx.fillRect(16, 72, 140, 38);
    ctx.strokeStyle = "#38bdf8";
    ctx.strokeRect(16, 72, 140, 38);
    ctx.fillStyle = "#9ca3af";
    ctx.fillText("DIST", 24, 78);
    ctx.fillStyle = "#e5e7eb";
    ctx.fillText(game.distance.toString() + "m", 24, 92);

    const spX = canvas.width - 180;
    ctx.fillStyle = "#022c22";
    ctx.fillRect(spX, 16, 164, 46);
    ctx.strokeStyle = "#22c55e";
    ctx.strokeRect(spX, 16, 164, 46);
    ctx.fillStyle = "#6ee7b7";
    ctx.fillText("SAVED (S)", spX + 8, 22);
    ctx.fillStyle = "#bbf7d0";
    ctx.font = "bold 20px monospace";
    ctx.fillText(game.savingsPot.toString(), spX + 8, 38);

    ctx.font = "14px monospace";
    ctx.fillStyle = "#020617";
    ctx.fillRect(spX, 72, 164, 38);
    ctx.strokeStyle = "#4b5563";
    ctx.strokeRect(spX, 72, 164, 38);
    ctx.fillStyle = "#facc15";
    ctx.fillText("HALAL: " + game.greenCoins, spX + 8, 78);
    ctx.fillStyle = "#fca5a5";
    ctx.fillText("RIBA: " + game.redCoins, spX + 8, 94);

    const barX = canvas.width / 2 - 180;
    const barY = 20;
    const barW = 360;
    const barH = 22;

    ctx.fillStyle = "#020617";
    ctx.fillRect(barX, barY, barW, barH);
    ctx.strokeStyle = "#9ca3af";
    ctx.strokeRect(barX, barY, barW, barH);

    const ratio = game.necessityMeter / 100;
    const color =
      ratio > 0.6 ? "#22c55e" : ratio > 0.3 ? "#eab308" : "#ef4444";
    ctx.fillStyle = color;
    ctx.fillRect(barX + 2, barY + 2, (barW - 4) * Math.max(0, ratio), barH - 4);

    ctx.fillStyle = "#e5e7eb";
    ctx.font = "12px monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(
      "NECESSITY " + Math.round(game.necessityMeter) + "%",
      barX + barW / 2,
      barY + barH / 2
    );

    if (game.hasKestrlCard) {
      const secs = Math.ceil(game.kestrlCardTimer / 60);
      ctx.font = "14px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillStyle = "#020617";
      ctx.fillRect(canvas.width / 2 - 80, 56, 160, 32);
      ctx.strokeStyle = "#06b6d4";
      ctx.strokeRect(canvas.width / 2 - 80, 56, 160, 32);
      ctx.fillStyle = "#67e8f9";
      ctx.fillText("KESTRL CARD: " + secs + "s", canvas.width / 2, 62);
    }

    if (game.state === "gameover") {
      ctx.fillStyle = "rgba(15,23,42,0.7)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = "32px monospace";
      ctx.fillStyle = "#f87171";
      ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 40);

      ctx.font = "18px monospace";
      ctx.fillStyle = "#e5e7eb";
      ctx.fillText(
        "Final score: " + Math.floor(game.score),
        canvas.width / 2,
        canvas.height / 2
      );
      ctx.fillText(
        "Press SPACE / TAP to restart",
        canvas.width / 2,
        canvas.height / 2 + 40
      );
    }

    ctx.restore();
  }

  // ---------- LOOP ----------
  function gameLoop() {
    update();
    draw();
    animationId = requestAnimationFrame(gameLoop);
  }
</script>
</body>
</html>













    


