<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Riba Run - Canvas Demo</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: #020617;
      font-family: monospace;
    }
    #gameCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      touch-action: none;
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <script>
    // ====== CONSTANTS ======
    const GROUND_HEIGHT = 100;
    const PLAYER_WIDTH = 48;
    const PLAYER_HEIGHT = 56;
    const PLAYER_SLIDE_HEIGHT = 28;
    const GRAVITY = 0.55;
    const JUMP_FORCE = -14;
    const INITIAL_SPEED = 4.5;
    const MAX_SPEED = 10;
    const SPEED_INCREMENT = 0.0006;
    const COYOTE_TIME = 8;

    // ====== GAME STATE ======
    const game = {
      player: { x: 120, y: 0, velocityY: 0, isJumping: false, isSliding: false, slideTimer: 0 },
      obstacles: [],
      coins: [],
      powerUps: [],
      particles: [],
      parallaxLayers: [],
      monster: { x: -100, targetX: -100, size: 1 },
      coyoteCounter: 0,
      speed: INITIAL_SPEED,
      score: 0,
      greenCoins: 0,
      redCoins: 0,
      necessityMeter: 100,
      distance: 0,
      frameCount: 0,
      isRunning: true,
      groundY: 0,
      hasKestrlCard: false,
      kestrlCardTimer: 0,
      debtThreshold: -150,
      glitchIntensity: 0,
      revived: false,
    };

    let canvas, ctx;
    let animationId;

    // ====== INIT ======
    function initGame() {
      canvas = document.getElementById('gameCanvas');
      ctx = canvas.getContext('2d');

      resizeCanvas();

      window.addEventListener('resize', resizeCanvas);
      window.addEventListener('keydown', handleKeyDown);
      canvas.addEventListener('touchstart', handleTouch, { passive: false });

      gameLoop();
    }

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      game.groundY = canvas.height - GROUND_HEIGHT;
      game.player.y = game.groundY - PLAYER_HEIGHT;
      game.player.x = 120;
      game.obstacles = [];
      game.coins = [];
      game.powerUps = [];
      game.particles = [];
      game.monster = { x: -150, targetX: -150, size: 1 };
      game.coyoteCounter = 0;
      game.speed = INITIAL_SPEED;
      game.score = 0;
      game.greenCoins = 0;
      game.redCoins = 0;
      game.necessityMeter = 100;
      game.distance = 0;
      game.frameCount = 0;
      game.isRunning = true;
      game.player.isJumping = false;
      game.player.isSliding = false;
      game.player.velocityY = 0;
      game.hasKestrlCard = false;
      game.kestrlCardTimer = 0;
      game.glitchIntensity = 0;
      game.revived = false;

      game.parallaxLayers = [
        { x: 0, speed: 0.2, color: '#0f172a' },
        { x: 0, speed: 0.4, color: '#1e293b' },
        { x: 0, speed: 0.6, color: '#334155' }
      ];
    }

    // ====== INPUT ======
    function handleKeyDown(e) {
      if (e.code === 'Space' || e.code === 'ArrowUp') {
        e.preventDefault();
        handleJump();
      } else if (e.code === 'ArrowDown') {
        e.preventDefault();
        handleSlide();
      } else if (e.code === 'KeyS') {
        e.preventDefault();
        handleSave();
      }
    }

    function handleTouch(e) {
      e.preventDefault();
      const touch = e.touches[0];
      if (touch.clientY > window.innerHeight / 2) {
        handleSlide();
      } else {
        handleJump();
      }
    }

    // ====== HELPERS ======
    function spawnObstacle() {
      const types = ['low', 'high', 'double'];
      const type = types[Math.floor(Math.random() * types.length)];

      let obstacle = { x: canvas.width + 50, type, passed: false };

      if (type === 'low') {
        obstacle.y = game.groundY - 45;
        obstacle.width = 35;
        obstacle.height = 45;
      } else if (type === 'high') {
        obstacle.y = game.groundY - 90;
        obstacle.width = 45;
        obstacle.height = 35;
      } else {
        obstacle.y = game.groundY - 70;
        obstacle.width = 55;
        obstacle.height = 70;
      }

      game.obstacles.push(obstacle);
    }

    function spawnCoin() {
      const isGreen = Math.random() < 0.5;

      if (isGreen) {
        const positions = [
          { y: game.groundY - 50, count: 3 },
          { y: game.groundY - 80, count: 2 },
          { y: game.groundY - 110, count: 2 },
        ];
        const pos = positions[Math.floor(Math.random() * positions.length)];

        for (let i = 0; i < pos.count; i++) {
          game.coins.push({
            x: canvas.width + 50 + (i * 40),
            y: pos.y,
            radius: 18,
            isGreen: true,
            collected: false,
            pulsePhase: Math.random() * Math.PI * 2
          });
        }
      } else {
        const count = Math.floor(Math.random() * 2) + 1;
        for (let i = 0; i < count; i++) {
          game.coins.push({
            x: canvas.width + 50 + (i * 35),
            y: game.groundY - 45,
            radius: 14,
            isGreen: false,
            collected: false,
            pulsePhase: Math.random() * Math.PI * 2
          });
        }
      }
    }

    function spawnKestrlCard() {
      if (Math.random() < 0.25 && !game.hasKestrlCard && game.powerUps.length === 0) {
        game.powerUps.push({
          x: canvas.width + 50,
          y: game.groundY - 80,
          width: 50,
          height: 35,
          type: 'kestrlCard',
          pulsePhase: 0
        });
      }
    }

    function createParticles(x, y, color, count = 10) {
      for (let i = 0; i < count; i++) {
        game.particles.push({
          x, y,
          vx: (Math.random() - 0.5) * 8,
          vy: (Math.random() - 0.5) * 8,
          life: 1,
          color,
          size: Math.random() * 4 + 2
        });
      }
    }

    function handleJump() {
      const canJump = (!game.player.isJumping || game.coyoteCounter > 0) &&
                      !game.player.isSliding &&
                      game.isRunning;
      if (canJump) {
        game.player.velocityY = JUMP_FORCE;
        game.player.isJumping = true;
        game.coyoteCounter = 0;
      }
    }

    function handleSlide() {
      if (!game.player.isJumping && !game.player.isSliding && game.isRunning) {
        game.player.isSliding = true;
        game.player.slideTimer = 35;
      }
    }

    function handleSave() {
      if (game.score >= 10 && game.isRunning) {
        game.score -= 10;
        createParticles(game.player.x + PLAYER_WIDTH / 2, game.player.y, '#10b981', 8);
        // localStorage saving intentionally skipped in this HTML-only version
      }
    }

    // ====== UPDATE LOOP ======
    function update() {
      if (!game.isRunning) return;

      game.frameCount++;
      game.distance = Math.floor(game.frameCount * game.speed / 15);

      if (game.speed < MAX_SPEED) {
        game.speed += SPEED_INCREMENT;
      }

      // Kestrl Card timer
      if (game.hasKestrlCard) {
        game.kestrlCardTimer--;
        if (game.kestrlCardTimer <= 0) {
          game.hasKestrlCard = false;
        }
      }

      // Necessity
      game.necessityMeter = Math.max(0, game.necessityMeter - 0.03);
      if (game.necessityMeter <= 0) {
        game.score -= 0.5;
      }

      // Parallax
      game.parallaxLayers.forEach(layer => {
        layer.x -= game.speed * layer.speed;
        if (layer.x <= -canvas.width) layer.x = 0;
      });

      // Player
      const player = game.player;

      if (player.isSliding) {
        player.slideTimer--;
        if (player.slideTimer <= 0) {
          player.isSliding = false;
        }
      }

      player.velocityY += GRAVITY;
      player.y += player.velocityY;

      const playerHeight = player.isSliding ? PLAYER_SLIDE_HEIGHT : PLAYER_HEIGHT;
      if (player.y >= game.groundY - playerHeight) {
        player.y = game.groundY - playerHeight;
        player.velocityY = 0;
        player.isJumping = false;
        game.coyoteCounter = COYOTE_TIME;
      } else if (game.coyoteCounter > 0) {
        game.coyoteCounter--;
      }

      // Monster mechanics
      const monsterBaseX = -150;
      if (game.score < 0) {
        const debtAmount = Math.abs(game.score);
        game.monster.targetX = monsterBaseX + Math.min(debtAmount * 1.5, player.x - 30);
        game.monster.size = 1 + Math.min(debtAmount / 200, 1.5);
      } else {
        game.monster.targetX = monsterBaseX;
        game.monster.size = Math.max(1, game.monster.size - 0.01);
      }

      if (game.hasKestrlCard) {
        game.monster.targetX = monsterBaseX - 100;
      }

      game.monster.x += (game.monster.targetX - game.monster.x) * 0.05;

      // Glitch
      if (game.score < game.debtThreshold) {
        const debtBeyondThreshold = Math.abs(game.score) - Math.abs(game.debtThreshold);
        game.glitchIntensity = Math.min(1, debtBeyondThreshold / 200);
      } else {
        game.glitchIntensity = Math.max(0, game.glitchIntensity - 0.02);
      }

      // Monster catch
      if (game.monster.x >= player.x - 20) {
        game.isRunning = false;
        createParticles(player.x + PLAYER_WIDTH / 2, player.y + PLAYER_HEIGHT / 2, '#ef4444', 30);
        return;
      }

      // Spawn stuff
      if (game.frameCount % Math.max(70, 140 - Math.floor(game.speed * 4)) === 0) {
        spawnObstacle();
      }
      if (game.frameCount % 50 === 0) {
        spawnCoin();
      }
      if (game.frameCount % 120 === 0) {
        spawnKestrlCard();
      }

      // Obstacles
      game.obstacles = game.obstacles.filter(obs => {
        obs.x -= game.speed;

        const playerBox = {
          x: player.x,
          y: player.y,
          width: PLAYER_WIDTH - 10,
          height: player.isSliding ? PLAYER_SLIDE_HEIGHT : PLAYER_HEIGHT
        };

        if (
          playerBox.x < obs.x + obs.width - 5 &&
          playerBox.x + playerBox.width > obs.x + 5 &&
          playerBox.y < obs.y + obs.height &&
          playerBox.y + playerBox.height > obs.y
        ) {
          game.isRunning = false;
          createParticles(player.x + PLAYER_WIDTH / 2, player.y + PLAYER_HEIGHT / 2, '#ef4444', 25);
        }

        if (!obs.passed && obs.x + obs.width < player.x) {
          obs.passed = true;
          game.score += 5;
        }

        return obs.x > -100;
      });

      // Coins
      game.coins = game.coins.filter(coin => {
        coin.x -= game.speed;
        coin.pulsePhase += 0.1;

        const playerCenterX = player.x + PLAYER_WIDTH / 2;
        const playerCenterY = player.y + (player.isSliding ? PLAYER_SLIDE_HEIGHT : PLAYER_HEIGHT) / 2;
        const dist = Math.sqrt(
          Math.pow(coin.x - playerCenterX, 2) +
          Math.pow(coin.y - playerCenterY, 2)
        );

        if (dist < coin.radius + 35) {
          if (game.hasKestrlCard) {
            game.score += 10;
            game.necessityMeter = Math.min(100, game.necessityMeter + 8);
            createParticles(coin.x, coin.y, '#06b6d4', 10);
            if (coin.isGreen) game.greenCoins++;
            else game.redCoins++;
          } else if (coin.isGreen) {
            game.greenCoins++;
            game.score += 10;
            game.necessityMeter = Math.min(100, game.necessityMeter + 12);
            createParticles(coin.x, coin.y, '#10b981', 10);
          } else {
            game.redCoins++;
            game.score -= 50;
            game.necessityMeter = Math.min(100, game.necessityMeter + 5);
            createParticles(coin.x, coin.y, '#ef4444', 8);
          }
          return false;
        }

        return coin.x > -50;
      });

      // Power-ups
      game.powerUps = game.powerUps.filter(pu => {
        pu.x -= game.speed;
        pu.pulsePhase += 0.15;

        const playerCenterX = player.x + PLAYER_WIDTH / 2;
        const playerCenterY = player.y + PLAYER_HEIGHT / 2;

        if (
          playerCenterX > pu.x - 20 &&
          playerCenterX < pu.x + pu.width + 20 &&
          playerCenterY > pu.y - 20 &&
          playerCenterY < pu.y + pu.height + 20
        ) {
          game.hasKestrlCard = true;
          game.kestrlCardTimer = 600;
          createParticles(pu.x + pu.width / 2, pu.y + pu.height / 2, '#06b6d4', 20);
          return false;
        }

        return pu.x > -100;
      });

      // Particles life update
      game.particles = game.particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.03;
        return p.life > 0;
      });

      // Running dust
      if (!player.isJumping && !player.isSliding && game.frameCount % 8 === 0) {
        game.particles.push({
          x: player.x,
          y: game.groundY - 5,
          vx: -2,
          vy: -1,
          life: 0.5,
          color: '#c4a35a',
          size: 3
        });
      }
    }

    // ====== DRAW MONSTER ======
    function drawMonster(x, groundY, intensity, size) {
      const y = groundY - 70 * size;
      const breathe = Math.sin(Date.now() / 200) * 4;
      const pixelSize = 4;

      ctx.save();
      ctx.translate(x + 40 * size, y + 40 * size);
      ctx.scale(size, size);

      const drawPixelBlock = (px, py, w, h, color) => {
        ctx.fillStyle = color;
        ctx.fillRect(px * pixelSize, py * pixelSize, w * pixelSize, h * pixelSize);
      };

      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 60 + breathe);
      gradient.addColorStop(0, `rgba(139, 0, 0, ${0.4 + intensity * 0.3})`);
      gradient.addColorStop(0.6, `rgba(60, 0, 0, ${0.2 + intensity * 0.2})`);
      gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, 60 + breathe, 0, Math.PI * 2);
      ctx.fill();

      const bodyColor = '#1a0a0a';
      const shadowColor = '#0d0505';
      const highlightColor = '#2d1010';

      for (let row = -8; row <= 10; row++) {
        const width = row < -4 ? 4 + row + 4 : row > 6 ? 10 - (row - 6) * 2 : 8;
        for (let col = -width; col <= width; col++) {
          const shade = Math.random() > 0.7 ? highlightColor : bodyColor;
          drawPixelBlock(col, row, 1, 1, shade);
        }
      }

      // Horns
      drawPixelBlock(-6, -10, 2, 3, shadowColor);
      drawPixelBlock(-7, -12, 2, 2, shadowColor);
      drawPixelBlock(4, -10, 2, 3, shadowColor);
      drawPixelBlock(5, -12, 2, 2, shadowColor);

      // Eyes
      const eyeFlicker = Math.sin(Date.now() / 50) > 0 ? 1 : 0.7;
      ctx.shadowColor = '#ff0000';
      ctx.shadowBlur = 10 + intensity * 15;
      ctx.fillStyle = `rgba(255, 0, 0, ${eyeFlicker})`;
      drawPixelBlock(-4, -4, 2, 2, `rgba(255, 50, 50, ${eyeFlicker})`);
      drawPixelBlock(2, -4, 2, 2, `rgba(255, 50, 50, ${eyeFlicker})`);
      ctx.shadowBlur = 0;

      ctx.fillStyle = '#ffffff';
      drawPixelBlock(-3, -3, 1, 1, '#ffffff');
      drawPixelBlock(3, -3, 1, 1, '#ffffff');

      // Mouth
      ctx.fillStyle = '#330000';
      for (let i = -3; i <= 3; i++) {
        const toothHeight = i % 2 === 0 ? 2 : 1;
        drawPixelBlock(i, 4, 1, toothHeight, '#ff3333');
      }

      // Tendrils
      for (let i = 0; i < 5; i++) {
        const tendrilX = -4 + i * 2;
        const tendrilY = 10 + Math.sin(Date.now() / 100 + i) * 2;
        drawPixelBlock(tendrilX, tendrilY, 1, 3, shadowColor);
      }

      ctx.restore();
    }

    // ====== DRAW LOOP ======
    function draw() {
      ctx.imageSmoothingEnabled = false;

      // Background gradient
      const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      bgGradient.addColorStop(0, '#1a0a2e');
      bgGradient.addColorStop(0.3, '#2d1b4e');
      bgGradient.addColorStop(0.6, '#4a3070');
      bgGradient.addColorStop(1, '#6b4d8a');
      ctx.fillStyle = bgGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Stars
      ctx.fillStyle = '#ffffff';
      for (let i = 0; i < 50; i++) {
        const starX = (i * 137 + game.frameCount * 0.1) % canvas.width;
        const starY = (i * 89) % (game.groundY - 100);
        const twinkle = Math.sin(game.frameCount * 0.1 + i) > 0.5 ? 2 : 1;
        ctx.fillRect(Math.floor(starX), Math.floor(starY), twinkle, twinkle);
      }

      // Parallax mountains
      const parallaxColors = [
        { fill: '#1e0a3d', opacity: 0.9 },
        { fill: '#2a1550', opacity: 0.85 },
        { fill: '#3d2266', opacity: 0.8 },
        { fill: '#4f2f7a', opacity: 0.75 },
        { fill: '#613d8e', opacity: 0.7 },
      ];

      game.parallaxLayers.forEach((layer, index) => {
        if (index >= parallaxColors.length) return;
        ctx.fillStyle = parallaxColors[index].fill;
        ctx.globalAlpha = parallaxColors[index].opacity;

        const baseY = game.groundY - 20 - index * 35;
        ctx.beginPath();
        ctx.moveTo(0, canvas.height);
        for (let x = 0; x <= canvas.width; x += 16) {
          const height = Math.sin((x + layer.x) * 0.008) * (40 + index * 10) +
                         Math.sin((x + layer.x) * 0.003) * (20 + index * 5);
          ctx.lineTo(x, baseY - Math.floor(height / 8) * 8);
        }
        ctx.lineTo(canvas.width, canvas.height);
        ctx.closePath();
        ctx.fill();
      });
      ctx.globalAlpha = 1;

      // Kestrl card overlay
      if (game.hasKestrlCard) {
        ctx.fillStyle = 'rgba(0, 255, 255, 0.08)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        for (let y = 0; y < canvas.height; y += 4) {
          if ((y + game.frameCount) % 8 < 4) {
            ctx.fillStyle = 'rgba(0, 255, 255, 0.03)';
            ctx.fillRect(0, y, canvas.width, 2);
          }
        }
      }

      // Ground tiles
      const tileSize = 32;
      const tileColors = {
        top: '#c4a35a',
        topShade: '#a88b4a',
        mid: '#8b7355',
        dark: '#6b5344',
        outline: '#4a3828'
      };

      for (let x = -tileSize; x < canvas.width + tileSize; x += tileSize) {
        const offsetX = (x + game.frameCount * game.speed) % tileSize;
        const tileX = x - offsetX;

        ctx.fillStyle = tileColors.top;
        ctx.fillRect(tileX, game.groundY, tileSize, 8);
        ctx.fillStyle = tileColors.topShade;
        ctx.fillRect(tileX, game.groundY + 8, tileSize, 8);

        ctx.fillStyle = tileColors.mid;
        ctx.fillRect(tileX, game.groundY + 16, tileSize, tileSize);
        ctx.fillStyle = tileColors.dark;
        ctx.fillRect(tileX, game.groundY + 16 + tileSize, tileSize, GROUND_HEIGHT);

        ctx.fillStyle = tileColors.outline;
        ctx.fillRect(tileX, game.groundY, 2, GROUND_HEIGHT);
        ctx.fillRect(tileX, game.groundY + 16, tileSize, 2);
      }

      ctx.fillStyle = '#e8d48a';
      ctx.fillRect(0, game.groundY, canvas.width, 2);

      // Monster
      const monsterIntensity = game.score < 0 ? Math.min(1, Math.abs(game.score) / 200) : 0;
      if (game.monster.x > -200) {
        drawMonster(game.monster.x, game.groundY, monsterIntensity, game.monster.size);
      }

      // Everything else wrapped so errors don't kill the frame
      try {
        // Obstacles
        game.obstacles.forEach(obs => {
          const baseColor = '#7c3aed';
          const lightColor = '#a78bfa';
          const darkColor = '#4c1d95';
          const outlineColor = '#2e1065';

          ctx.fillStyle = outlineColor;
          ctx.beginPath();
          ctx.moveTo(obs.x + obs.width / 2, obs.y - 4);
          ctx.lineTo(obs.x + obs.width + 4, obs.y + obs.height);
          ctx.lineTo(obs.x - 4, obs.y + obs.height);
          ctx.closePath();
          ctx.fill();

          ctx.fillStyle = baseColor;
          ctx.beginPath();
          ctx.moveTo(obs.x + obs.width / 2, obs.y);
          ctx.lineTo(obs.x + obs.width, obs.y + obs.height);
          ctx.lineTo(obs.x, obs.y + obs.height);
          ctx.closePath();
          ctx.fill();

          ctx.fillStyle = lightColor;
          ctx.beginPath();
          ctx.moveTo(obs.x + obs.width / 2, obs.y);
          ctx.lineTo(obs.x + obs.width / 2 - 4, obs.y + obs.height);
          ctx.lineTo(obs.x, obs.y + obs.height);
          ctx.closePath();
          ctx.fill();

          ctx.fillStyle = darkColor;
          ctx.beginPath();
          ctx.moveTo(obs.x + obs.width / 2, obs.y);
          ctx.lineTo(obs.x + obs.width, obs.y + obs.height);
          ctx.lineTo(obs.x + obs.width / 2 + 8, obs.y + obs.height);
          ctx.closePath();
          ctx.fill();

          if (game.frameCount % 20 < 10) {
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(obs.x + obs.width / 2 - 2, obs.y + 8, 4, 4);
          }
        });

        // Power-ups
        game.powerUps.forEach(pu => {
          const pulse = Math.sin(pu.pulsePhase) * 2;
          const px = 4;

          ctx.save();
          ctx.translate(pu.x + pu.width / 2, pu.y + pu.height / 2);

          ctx.shadowColor = '#00ffff';
          ctx.shadowBlur = 20 + pulse * 3;

          const w = pu.width + pulse;
          const h = pu.height + pulse;

          ctx.fillStyle = '#00ffff';
          ctx.fillRect(-w/2 - px, -h/2 - px, w + px*2, h + px*2);

          ctx.fillStyle = '#0088aa';
          ctx.fillRect(-w/2, -h/2, w, h);

          ctx.fillStyle = '#00ddff';
          ctx.fillRect(-w/2, -h/2, w, px*2);
          ctx.fillRect(-w/2, -h/2, px*2, h);

          ctx.fillStyle = '#005566';
          ctx.fillRect(-w/2, h/2 - px*2, w, px*2);
          ctx.fillRect(w/2 - px*2, -h/2, px*2, h);

          ctx.shadowBlur = 0;
          ctx.fillStyle = '#ffffff';
          const s = px;
          ctx.fillRect(-2*s, -3*s, s, 6*s);
          ctx.fillRect(-s, -s, 2*s, s);
          ctx.fillRect(0, -3*s, s, 2*s);
          ctx.fillRect(0, s, s, 2*s);

          for (let i = 0; i < 4; i++) {
            const sparkleX = Math.sin(pu.pulsePhase * 2 + i * 1.5) * (w/2 + 10);
            const sparkleY = Math.cos(pu.pulsePhase * 2 + i * 1.5) * (h/2 + 10);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(sparkleX - px/2, sparkleY - px/2, px, px);
          }

          ctx.restore();
        });

        // Coins
        game.coins.forEach(coin => {
          const pulse = Math.sin(coin.pulsePhase) * 1;
          const size = coin.radius + pulse;
          const px = 3;

          ctx.save();
          ctx.translate(coin.x, coin.y);

          const spinPhase = Math.floor(coin.pulsePhase * 2) % 4;
          const widthMultiplier = [1, 0.7, 0.3, 0.7][spinPhase];
          ctx.scale(widthMultiplier, 1);

          if (game.hasKestrlCard) {
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#00ffff';
            ctx.fillRect(-size/2, -size/2, size, size);
            ctx.fillStyle = '#80ffff';
            ctx.fillRect(-size/2 + px, -size/2 + px, size - px*2, px*2);
            ctx.fillStyle = '#008888';
            ctx.fillRect(-size/2, size/2 - px*2, size, px*2);
          } else if (coin.isGreen) {
            ctx.shadowColor = '#00ff88';
            ctx.shadowBlur = 12 + pulse * 2;

            ctx.fillStyle = '#ffd700';
            ctx.fillRect(-size/2, -size/2, size, size);

            ctx.fillStyle = '#ffec80';
            ctx.fillRect(-size/2 + px, -size/2 + px, size/2 - px, px*2);
            ctx.fillRect(-size/2 + p







    


