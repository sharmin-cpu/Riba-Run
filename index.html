
<!-- tiny update to trigger GitHub Pages -->
import React, { useEffect, useRef, useCallback } from 'react';

const GROUND_HEIGHT = 100;
const PLAYER_WIDTH = 48;
const PLAYER_HEIGHT = 56;
const PLAYER_SLIDE_HEIGHT = 28;
const GRAVITY = 0.55; // Smoother SNES-style gravity
const JUMP_FORCE = -14;
const INITIAL_SPEED = 4.5;
const MAX_SPEED = 10;
const SPEED_INCREMENT = 0.0006;
const COYOTE_TIME = 8; // Frames of forgiving jump timing

export default function GameCanvas({ onGameOver, onUpdateStats }) {
    const canvasRef = useRef(null);
    const gameRef = useRef({
        player: { x: 120, y: 0, velocityY: 0, isJumping: false, isSliding: false, slideTimer: 0 },
        obstacles: [], // Keep empty - obstacles removed
        coins: [],
        powerUps: [],
        particles: [],
        parallaxLayers: [],
        monster: { x: -100, targetX: -100, size: 1 },
        coyoteCounter: 0,
        speed: INITIAL_SPEED,
        score: 0,
        greenCoins: 0,
        redCoins: 0,
        necessityMeter: 100,
        distance: 0,
        frameCount: 0,
        isRunning: true,
        groundY: 0,
        hasKestrlCard: false,
        kestrlCardTimer: 0,
        debtThreshold: -150,
        glitchIntensity: 0,
        revived: false
    });

    const initGame = useCallback((canvas) => {
        const game = gameRef.current;
        game.groundY = canvas.height - GROUND_HEIGHT;
        game.player.y = game.groundY - PLAYER_HEIGHT;
        game.player.x = 120;
        game.obstacles = []; // Keep empty - obstacles removed
        game.coins = [];
        game.powerUps = [];
        game.particles = [];
        game.monster = { x: -150, targetX: -150, size: 1 };
        game.coyoteCounter = 0;
        game.speed = INITIAL_SPEED;
        game.score = 0;
        game.greenCoins = 0;
        game.redCoins = 0;
        game.necessityMeter = 100;
        game.distance = 0;
        game.frameCount = 0;
        game.isRunning = true;
        game.player.isJumping = false;
        game.player.isSliding = false;
        game.player.velocityY = 0;
        game.hasKestrlCard = false;
        game.kestrlCardTimer = 0;
        game.glitchIntensity = 0;
        game.revived = false;

        game.parallaxLayers = [
            { x: 0, speed: 0.2, color: '#0f172a' },
            { x: 0, speed: 0.4, color: '#1e293b' },
            { x: 0, speed: 0.6, color: '#334155' }
        ];
    }, []);

    // REMOVED: spawnObstacle function completely
    const spawnCoin = useCallback((canvas) => {
        const game = gameRef.current;
        const isGreen = Math.random() < 0.5; // Increased chance for green coins
        
        if (isGreen) {
            // Spawn green coins in easier positions - at running height or low jump
            const positions = [
                { y: game.groundY - 50, count: 3 },  // Ground level - easiest
                { y: game.groundY - 80, count: 2 },  // Small jump
                { y: game.groundY - 110, count: 2 }, // Medium jump
            ];
            const pos = positions[Math.floor(Math.random() * positions.length)];
            
            // Spawn multiple green coins in a line for easier collection
            for (let i = 0; i < pos.count; i++) {
                game.coins.push({
                    x: canvas.width + 50 + (i * 40),
                    y: pos.y,
                    radius: 18, // Larger hitbox
                    isGreen: true,
                    collected: false,
                    pulsePhase: Math.random() * Math.PI * 2
                });
            }
        } else {
            // Red coins still on easy path but less frequent
            const count = Math.floor(Math.random() * 2) + 1;
            for (let i = 0; i < count; i++) {
                game.coins.push({
                    x: canvas.width + 50 + (i * 35),
                    y: game.groundY - 45,
                    radius: 14,
                    isGreen: false,
                    collected: false,
                    pulsePhase: Math.random() * Math.PI * 2
                });
            }
        }
    }, []);

    const spawnKestrlCard = useCallback((canvas) => {
        const game = gameRef.current;
        if (Math.random() < 0.25 && !game.hasKestrlCard && game.powerUps.length === 0) {
            game.powerUps.push({
                x: canvas.width + 50,
                y: game.groundY - 80, // Easier to reach height
                width: 50,
                height: 35,
                type: 'kestrlCard',
                pulsePhase: 0
            });
        }
    }, []);

    const createParticles = useCallback((x, y, color, count = 10) => {
        const game = gameRef.current;
        for (let i = 0; i < count; i++) {
            game.particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 8,
                vy: (Math.random() - 0.5) * 8,
                life: 1,
                color,
                size: Math.random() * 4 + 2
            });
        }
    }, []);

    const handleJump = useCallback(() => {
        const game = gameRef.current;
        // Allow jump if grounded OR within coyote time
        const canJump = (!game.player.isJumping || game.coyoteCounter > 0) && !game.player.isSliding && game.isRunning;
        if (canJump) {
            game.player.velocityY = JUMP_FORCE;
            game.player.isJumping = true;
            game.coyoteCounter = 0;
        }
    }, []);

    const handleSlide = useCallback(() => {
        const game = gameRef.current;
        if (!game.player.isJumping && !game.player.isSliding && game.isRunning) {
            game.player.isSliding = true;
            game.player.slideTimer = 35;
        }
    }, []);

    const handleSave = useCallback(() => {
        const game = gameRef.current;
        if (game.score >= 10 && game.isRunning) {
            game.score -= 10;
            createParticles(game.player.x + PLAYER_WIDTH / 2, game.player.y, '#10b981', 8);
            if (typeof window !== 'undefined') {
                const current = parseInt(localStorage.getItem('ribaRunSavings') || '0');
                localStorage.setItem('ribaRunSavings', (current + 10).toString());
            }
        }
    }, [createParticles]);

    const update = useCallback((canvas) => {
        const game = gameRef.current;
        if (!game.isRunning) return;

        game.frameCount++;
        game.distance = Math.floor(game.frameCount * game.speed / 15);

        if (game.speed < MAX_SPEED) {
            game.speed += SPEED_INCREMENT;
        }

        // Kestrl Card timer
        if (game.hasKestrlCard) {
            game.kestrlCardTimer--;
            if (game.kestrlCardTimer <= 0) {
                game.hasKestrlCard = false;
            }
        }

        // Necessity meter depletes
        game.necessityMeter = Math.max(0, game.necessityMeter - 0.03);
        
        // Score drains when necessity is empty
        if (game.necessityMeter <= 0) {
            game.score -= 0.5;
        }

        // Update parallax
        game.parallaxLayers.forEach(layer => {
            layer.x -= game.speed * layer.speed;
            if (layer.x <= -canvas.width) layer.x = 0;
        });

        // Update player
        const player = game.player;
        
        if (player.isSliding) {
            player.slideTimer--;
            if (player.slideTimer <= 0) {
                player.isSliding = false;
            }
        }

        player.velocityY += GRAVITY;
        player.y += player.velocityY;

        const playerHeight = player.isSliding ? PLAYER_SLIDE_HEIGHT : PLAYER_HEIGHT;
        if (player.y >= game.groundY - playerHeight) {
            player.y = game.groundY - playerHeight;
            player.velocityY = 0;
            player.isJumping = false;
            game.coyoteCounter = COYOTE_TIME; // Reset coyote time when grounded
        } else if (game.coyoteCounter > 0) {
            game.coyoteCounter--; // Countdown coyote time while airborne
        }

        // Monster mechanics - proximity based on debt
        const monsterBaseX = -150;
        if (game.score < 0) {
            const debtAmount = Math.abs(game.score);
            game.monster.targetX = monsterBaseX + Math.min(debtAmount * 1.5, player.x - 30);
            game.monster.size = 1 + Math.min(debtAmount / 200, 1.5); // Monster grows with debt
        } else {
            game.monster.targetX = monsterBaseX;
            game.monster.size = Math.max(1, game.monster.size - 0.01);
        }

        if (game.hasKestrlCard) {
            game.monster.targetX = monsterBaseX - 100;
        }

        game.monster.x += (game.monster.targetX - game.monster.x) * 0.05;

        // Vision of Debt - glitch effect
        if (game.score < game.debtThreshold) {
            const debtBeyondThreshold = Math.abs(game.score) - Math.abs(game.debtThreshold);
            game.glitchIntensity = Math.min(1, debtBeyondThreshold / 200);
        } else {
            game.glitchIntensity = Math.max(0, game.glitchIntensity - 0.02);
        }

        // Monster catches player
        if (game.monster.x >= player.x - 20) {
            game.isRunning = false;
            createParticles(player.x + PLAYER_WIDTH / 2, player.y + PLAYER_HEIGHT / 2, '#ef4444', 30);
            onGameOver(Math.floor(game.score), game.score);
            return;
        }

        // REMOVED: Obstacle spawning logic completely
        // Spawn coins
        if (game.frameCount % 50 === 0) {
            spawnCoin(canvas);
        }

        // Spawn Kestrl Card more frequently
        if (game.frameCount % 120 === 0) {
            spawnKestrlCard(canvas);
        }

        // REMOVED: Obstacle collision detection completely
        // Update coins
        game.coins = game.coins.filter(coin => {
            coin.x -= game.speed;
            coin.pulsePhase += 0.1;

            const playerCenterX = player.x + PLAYER_WIDTH / 2;
            const playerCenterY = player.y + (player.isSliding ? PLAYER_SLIDE_HEIGHT : PLAYER_HEIGHT) / 2;
            const dist = Math.sqrt(
                Math.pow(coin.x - playerCenterX, 2) +
                Math.pow(coin.y - playerCenterY, 2)
            );

            if (dist < coin.radius + 35) { // Larger collection radius
                if (game.hasKestrlCard) {
                    game.score += 10;
                    game.necessityMeter = Math.min(100, game.necessityMeter + 8);
                    createParticles(coin.x, coin.y, '#06b6d4', 10);
                    if (coin.isGreen) game.greenCoins++;
                    else game.redCoins++;
                } else if (coin.isGreen) {
                    game.greenCoins++;
                    game.score += 10;
                    game.necessityMeter = Math.min(100, game.necessityMeter + 12);
                    createParticles(coin.x, coin.y, '#10b981', 10);
                } else {
                    game.redCoins++;
                    game.score -= 50;
                    game.necessityMeter = Math.min(100, game.necessityMeter + 5);
                    createParticles(coin.x, coin.y, '#ef4444', 8);
                }
                return false;
            }

            return coin.x > -50;
        });

        // Update power-ups
        game.powerUps = game.powerUps.filter(pu => {
            pu.x -= game.speed;
            pu.pulsePhase += 0.15;

            const playerCenterX = player.x + PLAYER_WIDTH / 2;
            const playerCenterY = player.y + PLAYER_HEIGHT / 2;
            
            if (
                playerCenterX > pu.x - 20 &&
                playerCenterX < pu.x + pu.width + 20 &&
                playerCenterY > pu.y - 20 &&
                playerCenterY < pu.y + pu.height + 20
            ) {
                game.hasKestrlCard = true;
                game.kestrlCardTimer = 600; // 10 seconds at 60fps
                createParticles(pu.x + pu.width / 2, pu.y + pu.height / 2, '#06b6d4', 20);
                return false;
            }

            return pu.x > -100;
        });

        // Update particles
        game.particles = game.particles.filter(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.03;
            return p.life > 0;
        });

        // Update stats
        onUpdateStats({
            score: Math.floor(game.score),
            greenCoins: game.greenCoins,
            redCoins: game.redCoins,
            necessityMeter: game.necessityMeter,
            distance: game.distance,
            monsterDistance: Math.max(0, game.player.x - game.monster.x),
            hasKestrlCard: game.hasKestrlCard,
            kestrlCardTimer: game.kestrlCardTimer
        });
    }, [spawnCoin, spawnKestrlCard, createParticles, onGameOver, onUpdateStats]);

    const drawMonster = useCallback((ctx, x, groundY, intensity, size) => {
        const y = groundY - 70 * size;
        const breathe = Math.sin(Date.now() / 200) * 4;
        const pixelSize = 4;

        ctx.save();
        ctx.translate(x + 40 * size, y + 40 * size);
        ctx.scale(size, size);

        // 16-bit shadow demon silhouette
        const drawPixelBlock = (px, py, w, h, color) => {
            ctx.fillStyle = color;
            ctx.fillRect(px * pixelSize, py * pixelSize, w * pixelSize, h * pixelSize);
        };

        // Dark aura glow
        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 60 + breathe);
        gradient.addColorStop(0, `rgba(139, 0, 0, ${0.4 + intensity * 0.3})`);
        gradient.addColorStop(0.6, `rgba(60, 0, 0, ${0.2 + intensity * 0.2})`);
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, 60 + breathe, 0, Math.PI * 2);
        ctx.fill();

        // Pixelated demon body
        const bodyColor = '#1a0a0a';
        const shadowColor = '#0d0505';
        const highlightColor = '#2d1010';

        // Main body pixels
        for (let row = -8; row <= 10; row++) {
            const width = row < -4 ? 4 + row + 4 : row > 6 ? 10 - (row - 6) * 2 : 8;
            for (let col = -width; col <= width; col++) {
                const shade = Math.random() > 0.7 ? highlightColor : bodyColor;
                drawPixelBlock(col, row, 1, 1, shade);
            }
        }

        // Horns
        drawPixelBlock(-6, -10, 2, 3, shadowColor);
        drawPixelBlock(-7, -12, 2, 2, shadowColor);
        drawPixelBlock(4, -10, 2, 3, shadowColor);
        drawPixelBlock(5, -12, 2, 2, shadowColor);

        // Glowing eyes with CRT flicker
        const eyeFlicker = Math.sin(Date.now() / 50) > 0 ? 1 : 0.7;
        ctx.shadowColor = '#ff0000';
        ctx.shadowBlur = 10 + intensity * 15;
        ctx.fillStyle = `rgba(255, 0, 0, ${eyeFlicker})`;
        drawPixelBlock(-4, -4, 2, 2, `rgba(255, 50, 50, ${eyeFlicker})`);
        drawPixelBlock(2, -4, 2, 2, `rgba(255, 50, 50, ${eyeFlicker})`);
        ctx.shadowBlur = 0;

        // Pixel pupils
        ctx.fillStyle = '#ffffff';
        drawPixelBlock(-3, -3, 1, 1, '#ffffff');
        drawPixelBlock(3, -3, 1, 1, '#ffffff');

        // Jagged mouth
        ctx.fillStyle = '#330000';
        for (let i = -3; i <= 3; i++) {
            const toothHeight = i % 2 === 0 ? 2 : 1;
            drawPixelBlock(i, 4, 1, toothHeight, '#ff3333');
        }

        // Wispy tendrils at bottom
        for (let i = 0; i < 5; i++) {
            const tendrilX = -4 + i * 2;
            const tendrilY = 10 + Math.sin(Date.now() / 100 + i) * 2;
            drawPixelBlock(tendrilX, tendrilY, 1, 3, shadowColor);
        }

        ctx.restore();
    }, []);

    const draw = useCallback((ctx, canvas) => {
        const game = gameRef.current;
        ctx.imageSmoothingEnabled = false; // Crisp pixel art

        // 16-bit sky gradient (SNES style soft colors)
        const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        bgGradient.addColorStop(0, '#1a0a2e'); // Deep purple
        bgGradient.addColorStop(0.3, '#2d1b4e'); // Mid purple
        bgGradient.addColorStop(0.6, '#4a3070'); // Lighter purple
        bgGradient.addColorStop(1, '#6b4d8a'); // Washed purple
        ctx.fillStyle = bgGradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Pixel stars
        ctx.fillStyle = '#ffffff';
        for (let i = 0; i < 50; i++) {
            const starX = (i * 137 + game.frameCount * 0.1) % canvas.width;
            const starY = (i * 89) % (game.groundY - 100);
            const twinkle = Math.sin(game.frameCount * 0.1 + i) > 0.5 ? 2 : 1;
            ctx.fillRect(Math.floor(starX), Math.floor(starY), twinkle, twinkle);
        }

        // Parallax layers (5 layers, SNES style)
        const parallaxColors = [
            { fill: '#1e0a3d', opacity: 0.9 },  // Far mountains
            { fill: '#2a1550', opacity: 0.85 }, 
            { fill: '#3d2266', opacity: 0.8 },
            { fill: '#4f2f7a', opacity: 0.75 },
            { fill: '#613d8e', opacity: 0.7 },  // Near hills
        ];

        game.parallaxLayers.forEach((layer, index) => {
            if (index >= parallaxColors.length) return;
            ctx.fillStyle = parallaxColors[index].fill;
            ctx.globalAlpha = parallaxColors[index].opacity;

            // Blocky pixel mountains
            const baseY = game.groundY - 20 - index * 35;
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);

            for (let x = 0; x <= canvas.width; x += 16) { // 16px steps for pixel look
                const height = Math.sin((x + layer.x) * 0.008) * (40 + index * 10) +
                               Math.sin((x + layer.x) * 0.003) * (20 + index * 5);
                ctx.lineTo(x, baseY - Math.floor(height / 8) * 8); // Quantize to 8px
            }
            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();
        });
        ctx.globalAlpha = 1;

        // Kestrl Card effect - retro cyan scanline glow
        if (game.hasKestrlCard) {
            ctx.fillStyle = 'rgba(0, 255, 255, 0.08)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Scanline shimmer
            for (let y = 0; y < canvas.height; y += 4) {
                if ((y + game.frameCount) % 8 < 4) {
                    ctx.fillStyle = 'rgba(0, 255, 255, 0.03)';
                    ctx.fillRect(0, y, canvas.width, 2);
                }
            }
        }

        // 16-bit tile-based ground
        const tileSize = 32;
        const tileColors = {
            top: '#c4a35a',      // Sandy top
            topShade: '#a88b4a', // Top shade
            mid: '#8b7355',      // Mid brown
            dark: '#6b5344',     // Dark brown
            outline: '#4a3828'   // Dark outline
        };

        // Draw tile rows
        for (let x = -tileSize; x < canvas.width + tileSize; x += tileSize) {
            const offsetX = (x + game.frameCount * game.speed) % tileSize;
            const tileX = x - offsetX;

            // Top grass/edge tiles
            ctx.fillStyle = tileColors.top;
            ctx.fillRect(tileX, game.groundY, tileSize, 8);
            ctx.fillStyle = tileColors.topShade;
            ctx.fillRect(tileX, game.groundY + 8, tileSize, 8);

            // Main ground tiles
            ctx.fillStyle = tileColors.mid;
            ctx.fillRect(tileX, game.groundY + 16, tileSize, tileSize);
            ctx.fillStyle = tileColors.dark;
            ctx.fillRect(tileX, game.groundY + 16 + tileSize, tileSize, GROUND_HEIGHT);

            // Tile grid lines (pixel art style)
            ctx.fillStyle = tileColors.outline;
            ctx.fillRect(tileX, game.groundY, 2, GROUND_HEIGHT);
            ctx.fillRect(tileX, game.groundY + 16, tileSize, 2);
        }

        // Ground top edge highlight
        ctx.fillStyle = '#e8d48a';
        ctx.fillRect(0, game.groundY, canvas.width, 2);

        // Draw Riba Monster
        const monsterIntensity = game.score < 0 ? Math.min(1, Math.abs(game.score) / 200) : 0;
        if (game.monster.x > -200) {
            drawMonster(ctx, game.monster.x, game.groundY, monsterIntensity, game.monster.size);
        }

        // REMOVED: Obstacle drawing code completely

        // Draw power-ups (Kestrl Card - pixel art style)
        game.powerUps.forEach(pu => {
            const pulse = Math.sin(pu.pulsePhase) * 2;
            const px = 4; // pixel size

            ctx.save();
            ctx.translate(pu.x + pu.width / 2, pu.y + pu.height / 2);

            // Glowing aura
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 20 + pulse * 3;

            // Card body (pixel art)
            const w = pu.width + pulse;
            const h = pu.height + pulse;

            // Outer glow rect
            ctx.fillStyle = '#00ffff';
            ctx.fillRect(-w/2 - px, -h/2 - px, w + px*2, h + px*2);

            // Main card
            ctx.fillStyle = '#0088aa';
            ctx.fillRect(-w/2, -h/2, w, h);

            // Highlight edge
            ctx.fillStyle = '#00ddff';
            ctx.fillRect(-w/2, -h/2, w, px*2);
            ctx.fillRect(-w/2, -h/2, px*2, h);

            // Shadow edge
            ctx.fillStyle = '#005566';
            ctx.fillRect(0, h/2 - px*2, w, px*2);
            ctx.fillRect(w/2 - px*2, 0, px*2, h);

            // Center 'K' logo (pixel style)
            ctx.shadowBlur = 0;
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(-px*2, -px*3, px, px*6); // Vertical line
            ctx.fillRect(-px, -px, px*2, px); // Middle
            ctx.fillRect(0, -px*3, px, px*2); // Top diagonal
            ctx.fillRect(0, px, px, px*2); // Bottom diagonal

            // Sparkle particles
            for (let i = 0; i < 4; i++) {
                const sparkleX = Math.sin(pu.pulsePhase * 2 + i * 1.5) * (w/2 + 10);
                const sparkleY = Math.cos(pu.pulsePhase * 2 + i * 1.5) * (h/2 + 10);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(sparkleX - px/2, sparkleY - px/2, px, px);
            }

            ctx.restore();
        });

        // Draw coins (16-bit pixel art style)
        game.coins.forEach(coin => {
            const pulse = Math.sin(coin.pulsePhase) * 1;
            const size = coin.radius + pulse;
            const px = 3; // pixel size

            ctx.save();
            ctx.translate(coin.x, coin.y);

            // Rotation animation (coin spin)
            const spinPhase = Math.floor(coin.pulsePhase * 2) % 4;
            const widthMultiplier = [1, 0.7, 0.3, 0.7][spinPhase];
            ctx.scale(widthMultiplier, 1);

            if (game.hasKestrlCard) {
                // Cyan powered-up coin
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.fillStyle = '#00ffff';
                ctx.fillRect(-size/2, -size/2, size, size);
                ctx.fillStyle = '#80ffff';
                ctx.fillRect(-size/2 + px, -size/2 + px, size - px*2, px*2);
                ctx.fillStyle = '#008888';
                ctx.fillRect(-size/2, size/2 - px*2, size, px*2);
            } else if (coin.isGreen) {
                // Golden Halal coin with green pixel aura
                // Green aura glow
                ctx.shadowColor = '#00ff88';
                ctx.shadowBlur = 12 + pulse * 2;

                // Gold coin body
                ctx.fillStyle = '#ffd700';
                ctx.fillRect(-size/2, -size/2, size, size);

                // Highlight (top-left)
                ctx.fillStyle = '#ffec80';
                ctx.fillRect(-size/2 + px, -size/2 + px, size/2 - px, px*2);
                ctx.fillRect(-size/2 + px, -size/2 + px, px*2, size/2 - px);

                // Shadow (bottom-right)
                ctx.fillStyle = '#b8860b';
                ctx.fillRect(0, size/2 - px*2, size/2, px*2);
                ctx.fillRect(size/2 - px*2, 0, px*2, size/2);

                // Center sparkle
                if (game.frameCount % 30 < 15) {
                    ctx.fillStyle = '#ffffff';
                    ctx.fillRect(-px, -px, px*2, px*2);
                }
            } else {
                // Red Riba coin with CRT flicker
                const flicker = Math.sin(game.frameCount * 0.5) > 0 ? 1 : 0.6;
                ctx.shadowColor = `rgba(255, 0, 0, ${flicker})`;
                ctx.shadowBlur = 10 + Math.sin(game.frameCount * 0.3) * 5;

                // Dark red body
                ctx.fillStyle = '#cc0000';
                ctx.fillRect(-size/2, -size/2, size, size);

                // Highlight
                ctx.fillStyle = '#ff4444';
                ctx.fillRect(-size/2 + px, -size/2 + px, size - px*2, px*2);

                // Dark edge
                ctx.fillStyle = '#880000';
                ctx.fillRect(-size/2, size/2 - px*2, size, px*2);

                // Skull/danger symbol (simplified pixel)
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(-px*2, -px, px, px);
                ctx.fillRect(px, -px, px, px);
                ctx.fillRect(-px, px, px*2, px);
            }

            ctx.shadowBlur = 0;
            ctx.restore();

            // Value text below coin
            ctx.font = 'bold 10px monospace';
            ctx.textAlign = 'center';
            ctx.fillStyle = game.hasKestrlCard ? '#00ffff' : (coin.isGreen ? '#88ff88' : '#ff8888');
            ctx.fillText(game.hasKestrlCard ? '+10' : (coin.isGreen ? '+10' : '-50'), coin.x, coin.y + size + 10);
        });

        // Draw player (Kestrel - 16-bit sprite style)
        const player = game.player;
        const playerHeight = player.isSliding ? PLAYER_SLIDE_HEIGHT : PLAYER_HEIGHT;
        const px = 4; // pixel size

        ctx.save();
        ctx.translate(player.x + PLAYER_WIDTH / 2, player.y + playerHeight / 2);

        if (player.isSliding) {
            ctx.rotate(-Math.PI / 8);
            ctx.scale(1, 0.6);
        }

        // Kestrl Card aura
        if (game.hasKestrlCard) {
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 25;
        }

        // Animation frame based on running
        const runFrame = Math.floor(game.frameCount / 6) % 4;
        const wingFrame = player.isJumping ? 2 : runFrame;
        const legOffset = [0, -2, 0, 2][runFrame];

        // Color palette (SNES style)
        const colors = {
            bodyDark: '#5c3d2e',
            bodyMid: '#8b5e3c',
            bodyLight: '#a67c52',
            wingDark: '#4a2d1a',
            wingMid: '#6b4423',
            beak: game.hasKestrlCard ? '#00ffff' : '#2d8a4e',
            beakLight: game.hasKestrlCard ? '#80ffff' : '#4ade80',
            eye: '#1a1a2e',
            eyeShine: '#ffffff',
            outline: '#2d1f1a'
        };

        // Draw pixel blocks helper
        const drawPx =
     
        
          
     
