<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Halal Realm – Riba Run</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: #000000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #gameCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
    }
  </style>
</head>
<body onload="init()">
<canvas id="gameCanvas"></canvas>

<script>
  // ---------- CONSTANTS ----------
  const GROUND_HEIGHT = 100;
  const PLAYER_WIDTH = 48;
  const PLAYER_HEIGHT = 56;
  const PLAYER_SLIDE_HEIGHT = 28;
  const GRAVITY = 0.55;
  const JUMP_FORCE = -14;

  const INITIAL_SPEED = 4.5;
  const MAX_SPEED = 16;
  const BASE_SPEED_INCREMENT = 0.0012;
  const COYOTE_TIME = 8;

  // ---------- GAME STATE ----------
  const game = {
    state: "map",             // "map" | "running" | "gameover"
    player: {
      x: 120,
      y: 0,
      velocityY: 0,
      isJumping: false,
      isSliding: false,
      slideTimer: 0,
    },
    obstacles: [],
    coins: [],
    powerUps: [],
    particles: [],
    parallaxLayers: [],
    monster: { x: -150, targetX: -150, size: 1 },
    coyoteCounter: 0,
    speed: INITIAL_SPEED,
    score: 0,
    greenCoins: 0,
    redCoins: 0,
    necessityMeter: 100,
    distance: 0,
    frameCount: 0,
    groundY: 0,
    hasKestrlCard: false,
    kestrlCardTimer: 0,
    debtThreshold: -150,
    glitchIntensity: 0,
    gameOverTime: 0,
    savingsPot: 0,
  };

  let canvas, ctx;
  let animationId;

  // ---------- MAP HELPERS ----------
  function getMapRegions() {
    const w = canvas.width;
    const h = canvas.height;

    // Helper to stay inside parchment area
    const margin = Math.min(w, h) * 0.10;
    const mapX = (u) => margin + u * (w - margin * 2);
    const mapY = (v) => margin + v * (h - margin * 2);

    const baseRx = Math.max(70, w * 0.06);
    const baseRy = Math.max(45, h * 0.05);

    return [
      {
        id: "riba",
        name: "Kingdom of Syarmin",
        subtitle: "Riba Market",
        status: "unlocked",
        cx: mapX(0.63),
        cy: mapY(0.60),
        rx: baseRx * 1.2,
        ry: baseRy * 1.2,
      },
      {
        id: "qard",
        name: "Qard Valley",
        subtitle: "Student Debt Ravine",
        status: "locked",
        cx: mapX(0.52),
        cy: mapY(0.30),
        rx: baseRx,
        ry: baseRy,
      },
      {
        id: "bayt",
        name: "Bayt al-Tijara",
        subtitle: "Consumer Credit Bazaar",
        status: "locked",
        cx: mapX(0.30),
        cy: mapY(0.47),
        rx: baseRx,
        ry: baseRy,
      },
      {
        id: "murabaha",
        name: "Murabaha Peaks",
        subtitle: "Buy-Now Mountain Pass",
        status: "locked",
        cx: mapX(0.22),
        cy: mapY(0.72),
        rx: baseRx,
        ry: baseRy,
      },
      {
        id: "sukuk",
        name: "Sukuk Sands",
        subtitle: "Speculation Stormfront",
        status: "locked",
        cx: mapX(0.83),
        cy: mapY(0.37),
        rx: baseRx,
        ry: baseRy,
      },
      {
        id: "takaful",
        name: "Takaful Isles",
        subtitle: "Tides of Shared Risk",
        status: "locked",
        cx: mapX(0.63),
        cy: mapY(0.80),
        rx: baseRx * 1.05,
        ry: baseRy * 1.05,
      },
    ];
  }

  function pointInRegion(x, y, region) {
    const dx = x - region.cx;
    const dy = y - region.cy;
    const val = (dx * dx) / (region.rx * region.rx) + (dy * dy) / (region.ry * region.ry);
    return val <= 1;
  }

  function handleMapClick(x, y) {
    const regions = getMapRegions();
    for (const region of regions) {
      if (pointInRegion(x, y, region) && region.id === "riba") {
        startRibaRun();
        return;
      }
    }
  }

  function startRibaRun() {
    resetRun();        // sets state to "running" and reinitialises the runner
  }

  // ---------- INIT ----------
  function init() {
    canvas = document.getElementById("gameCanvas");
    ctx = canvas.getContext("2d");

    try {
      const saved = localStorage.getItem("ribaRunSavings");
      if (saved !== null) game.savingsPot = parseInt(saved, 10) || 0;
    } catch (e) {
      game.savingsPot = 0;
    }

    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    window.addEventListener("keydown", handleKeyDown);
    canvas.addEventListener("touchstart", handleTouch, { passive: false });
    canvas.addEventListener("click", handleClick);

    gameLoop();
  }

  function resetRun() {
    game.state = "running";
    game.obstacles = [];
    game.coins = [];
    game.powerUps = [];
    game.particles = [];
    game.parallaxLayers = [
      { x: 0, speed: 0.2 },
      { x: 0, speed: 0.4 },
      { x: 0, speed: 0.6 },
    ];

    game.monster = { x: -150, targetX: -150, size: 1 };
    game.coyoteCounter = 0;
    game.speed = INITIAL_SPEED;
    game.score = 0;
    game.greenCoins = 0;
    game.redCoins = 0;
    game.necessityMeter = 100;
    game.distance = 0;
    game.frameCount = 0;
    game.hasKestrlCard = false;
    game.kestrlCardTimer = 0;
    game.glitchIntensity = 0;
    game.gameOverTime = 0;

    game.player.x = 120;
    game.player.y = game.groundY - PLAYER_HEIGHT;
    game.player.velocityY = 0;
    game.player.isJumping = false;
    game.player.isSliding = false;
    game.player.slideTimer = 0;
  }

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    game.groundY = canvas.height - GROUND_HEIGHT;
    if (game.state === "running") {
      game.player.y = game.groundY - PLAYER_HEIGHT;
    }
  }

  // ---------- INPUT ----------
  function handleKeyDown(e) {
    if (game.state === "map") {
      if (e.code === "Space" || e.code === "Enter") {
        // quick-start Riba level
        startRibaRun();
      }
      return;
    }

    if (game.state === "gameover") {
      if (e.code === "Space" || e.code === "Enter") {
        resetRun();
      }
      return;
    }

    if (e.code === "Space" || e.code === "ArrowUp") {
      e.preventDefault();
      handleJump();
    } else if (e.code === "ArrowDown") {
      e.preventDefault();
      handleSlide();
    } else if (e.code === "KeyS") {
      e.preventDefault();
      handleSave();
    }
  }

  function handleTouch(e) {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const touch = e.touches[0];
    const x = touch.clientX - rect.left;
    const y = touch.clientY - rect.top;

    if (game.state === "map") {
      handleMapClick(x, y);
      return;
    }

    if (game.state === "gameover") {
      resetRun();
      return;
    }

    if (y > window.innerHeight / 2) {
      handleSlide();
    } else {
      handleJump();
    }
  }

  function handleClick(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    if (game.state === "map") {
      handleMapClick(x, y);
    }
  }

  function handleJump() {
    const p = game.player;
    const canJump =
      (!p.isJumping || game.coyoteCounter > 0) &&
      !p.isSliding &&
      game.state === "running";
    if (canJump) {
      p.velocityY = JUMP_FORCE;
      p.isJumping = true;
      game.coyoteCounter = 0;
    }
  }

  function handleSlide() {
    const p = game.player;
    if (!p.isJumping && !p.isSliding && game.state === "running") {
      p.isSliding = true;
      p.slideTimer = 35;
    }
  }

  function handleSave() {
    if (game.state !== "running") return;
    if (game.score >= 10) {
      game.score -= 10;
      game.savingsPot += 10;
      try {
        localStorage.setItem("ribaRunSavings", String(game.savingsPot));
      } catch (e) {}

      createParticles(
        game.player.x + PLAYER_WIDTH / 2,
        game.player.y,
        "#22c55e",
        10
      );
    }
  }

  // ---------- SPAWN HELPERS ----------
  function spawnObstacle() {
    const types = ["low", "high", "double"];
    const type = types[Math.floor(Math.random() * types.length)];

    let obstacle = { x: canvas.width + 50, type, passed: false };

    if (type === "low") {
      obstacle.y = game.groundY - 45;
      obstacle.width = 35;
      obstacle.height = 45;
    } else if (type === "high") {
      obstacle.y = game.groundY - 90;
      obstacle.width = 45;
      obstacle.height = 35;
    } else {
      obstacle.y = game.groundY - 70;
      obstacle.width = 55;
      obstacle.height = 70;
    }

    game.obstacles.push(obstacle);
  }

  function spawnCoin() {
    const spawnGreen = Math.random() < 0.6;

    if (spawnGreen) {
      const positions = [
        { y: game.groundY - 120, count: 3 },
        { y: game.groundY - 90, count: 2 },
      ];
      const pos = positions[Math.floor(Math.random() * positions.length)];
      for (let i = 0; i < pos.count; i++) {
        game.coins.push({
          x: canvas.width + 60 + i * 40,
          y: pos.y,
          radius: 16,
          isGreen: true,
          pulsePhase: Math.random() * Math.PI * 2,
        });
      }
    } else {
      const count = Math.floor(Math.random() * 2) + 1;
      for (let i = 0; i < count; i++) {
        game.coins.push({
          x: canvas.width + 60 + i * 35,
          y: game.groundY - 40,
          radius: 14,
          isGreen: false,
          pulsePhase: Math.random() * Math.PI * 2,
        });
      }
    }
  }

  function spawnKestrlCard() {
    if (
      Math.random() < 0.25 &&
      !game.hasKestrlCard &&
      game.powerUps.length === 0
    ) {
      game.powerUps.push({
        x: canvas.width + 50,
        y: game.groundY - 90,
        width: 50,
        height: 32,
        pulsePhase: 0,
      });
    }
  }

  function createParticles(x, y, color, count) {
    const n = count || 10;
    for (let i = 0; i < n; i++) {
      game.particles.push({
        x,
        y,
        vx: (Math.random() - 0.5) * 6,
        vy: (Math.random() - 0.5) * 6,
        life: 1,
        color,
        size: Math.random() * 3 + 2,
      });
    }
  }

  // ---------- DEATH / REVIVE ----------
  function triggerDeath() {
    if (game.state !== "running") return;

    const finalScore = Math.floor(game.score);
    const currentDebt = finalScore < 0 ? finalScore : 0;
    const reviveCost = 50 + Math.abs(currentDebt);

    if (game.savingsPot >= reviveCost) {
      // revive using savings
      game.savingsPot -= reviveCost;
      try {
        localStorage.setItem("ribaRunSavings", String(game.savingsPot));
      } catch (e) {}

      game.score = Math.max(0, finalScore);
      game.necessityMeter = 50;
      game.hasKestrlCard = false;
      game.kestrlCardTimer = 0;
      game.glitchIntensity = 0;

      game.monster.x = -260;
      game.monster.targetX = -260;
      game.monster.size = 1;

      createParticles(
        game.player.x + PLAYER_WIDTH / 2,
        game.player.y,
        "#22c55e",
        25
      );
    } else {
      game.state = "gameover";
      game.gameOverTime = 0;
    }
  }

  // ---------- UPDATE ----------
  function update() {
    // Map idle animation
    if (game.state === "map") {
      game.frameCount++;
      return;
    }

    if (game.state !== "running") {
      if (game.state === "gameover") game.gameOverTime++;
      return;
    }

    game.frameCount++;
    game.distance = Math.floor((game.frameCount * game.speed) / 15);

    const distanceFactor = Math.min(game.distance / 800, 1.5);
    const targetSpeed = Math.min(INITIAL_SPEED + distanceFactor * 6, MAX_SPEED);
    if (game.speed < targetSpeed) {
      game.speed += BASE_SPEED_INCREMENT * (1 + distanceFactor);
    }

    if (game.hasKestrlCard) {
      game.kestrlCardTimer--;
      if (game.kestrlCardTimer <= 0) {
        game.hasKestrlCard = false;
      }
    }

    game.necessityMeter = Math.max(0, game.necessityMeter - 0.03);
    if (game.necessityMeter <= 0) {
      game.score -= 0.5;
    }

    game.parallaxLayers.forEach((layer) => {
      layer.x -= game.speed * layer.speed;
      if (layer.x <= -canvas.width) layer.x += canvas.width;
    });

    const p = game.player;

    if (p.isSliding) {
      p.slideTimer--;
      if (p.slideTimer <= 0) p.isSliding = false;
    }

    p.velocityY += GRAVITY;
    p.y += p.velocityY;

    const playerHeight = p.isSliding ? PLAYER_SLIDE_HEIGHT : PLAYER_HEIGHT;
    if (p.y >= game.groundY - playerHeight) {
      p.y = game.groundY - playerHeight;
      p.velocityY = 0;
      p.isJumping = false;
      game.coyoteCounter = COYOTE_TIME;
    } else if (game.coyoteCounter > 0) {
      game.coyoteCounter--;
    }

    const monsterBaseX = -150;
    if (game.score < 0) {
      const debt = Math.abs(game.score);
      game.monster.targetX = monsterBaseX + Math.min(debt * 1.5, p.x - 80);
      game.monster.size = 1 + Math.min(debt / 200, 1.5);
    } else {
      game.monster.targetX = monsterBaseX;
      game.monster.size = Math.max(1, game.monster.size - 0.01);
    }

    if (game.hasKestrlCard) {
      game.monster.targetX = monsterBaseX - 150;
    }

    game.monster.x += (game.monster.targetX - game.monster.x) * 0.05;

    if (game.score < game.debtThreshold) {
      const excessDebt =
        Math.abs(game.score) - Math.abs(game.debtThreshold);
      game.glitchIntensity = Math.min(1, excessDebt / 200);
    } else {
      game.glitchIntensity = Math.max(0, game.glitchIntensity - 0.02);
    }

    if (game.monster.x + 40 >= p.x) {
      createParticles(
        p.x + PLAYER_WIDTH / 2,
        p.y + PLAYER_HEIGHT / 2,
        "#ef4444",
        25
      );
      triggerDeath();
    }

    if (game.frameCount % Math.max(60, 130 - Math.floor(game.speed * 3)) === 0) {
      spawnObstacle();
    }
    if (game.frameCount % 50 === 0) spawnCoin();
    if (game.frameCount % 120 === 0) spawnKestrlCard();

    game.obstacles = game.obstacles.filter((obs) => {
      obs.x -= game.speed;

      const playerBox = {
        x: p.x,
        y: p.y,
        width: PLAYER_WIDTH - 10,
        height: playerHeight,
      };

      if (
        playerBox.x < obs.x + obs.width - 5 &&
        playerBox.x + playerBox.width > obs.x + 5 &&
        playerBox.y < obs.y + obs.height &&
        playerBox.y + playerBox.height > obs.y
      ) {
        createParticles(
          p.x + PLAYER_WIDTH / 2,
          p.y + PLAYER_HEIGHT / 2,
          "#ef4444",
          20
        );
        triggerDeath();
      }

      if (!obs.passed && obs.x + obs.width < p.x) {
        obs.passed = true;
        game.score += 5;
      }

      return obs.x > -100;
    });

    game.coins = game.coins.filter((coin) => {
      coin.x -= game.speed;
      coin.pulsePhase += 0.1;

      const centerX = p.x + PLAYER_WIDTH / 2;
      const centerY = p.y + playerHeight / 2;
      const dx = coin.x - centerX;
      const dy = coin.y - centerY;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < coin.radius + 28) {
        if (game.hasKestrlCard) {
          game.score += 10;
          game.necessityMeter = Math.min(100, game.necessityMeter + 8);
          createParticles(coin.x, coin.y, "#06b6d4", 10);
        } else if (coin.isGreen) {
          game.greenCoins++;
          game.score += 10;
          game.necessityMeter = Math.min(100, game.necessityMeter + 12);
          createParticles(coin.x, coin.y, "#22c55e", 10);
        } else {
          game.redCoins++;
          game.score -= 50;
          game.necessityMeter = Math.min(100, game.necessityMeter + 5);
          createParticles(coin.x, coin.y, "#ef4444", 10);
          game.glitchIntensity = Math.min(1, game.glitchIntensity + 0.18);
        }
        return false;
      }

      return coin.x > -40;
    });

    game.powerUps = game.powerUps.filter((pu) => {
      pu.x -= game.speed;
      pu.pulsePhase += 0.12;

      const centerX = p.x + PLAYER_WIDTH / 2;
      const centerY = p.y + playerHeight / 2;
      if (
        centerX > pu.x - 20 &&
        centerX < pu.x + pu.width + 20 &&
        centerY > pu.y - 20 &&
        centerY < pu.y + pu.height + 20
      ) {
        game.hasKestrlCard = true;
        game.kestrlCardTimer = 600;
        createParticles(
          pu.x + pu.width / 2,
          pu.y + pu.height / 2,
          "#06b6d4",
          20
        );
        game.monster.x = -260;
        game.monster.targetX = -260;
        return false;
      }

      return pu.x > -100;
    });

    game.particles = game.particles.filter((p2) => {
      p2.x += p2.vx;
      p2.y += p2.vy;
      p2.life -= 0.03;
      return p2.life > 0;
    });

    if (!p.isJumping && !p.isSliding && game.frameCount % 8 === 0) {
      game.particles.push({
        x: p.x,
        y: game.groundY - 4,
        vx: -2,
        vy: -1,
        life: 0.5,
        color: "#facc15",
        size: 3,
      });
    }
  }

  // ---------- DRAW HELPERS ----------
  function drawPixelMonster() {
    const m = game.monster;
    const intensity =
      game.score < 0 ? Math.min(1, Math.abs(game.score) / 200) : 0;

    const pixel = 4;
    const baseSize = 10;

    ctx.save();
    ctx.translate(m.x + 40 * m.size, game.groundY - 70 * m.size);
    ctx.scale(m.size, m.size);

    const radius = baseSize * pixel * 1.6;
    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
    gradient.addColorStop(0, "rgba(15,23,42,0.9)");
    gradient.addColorStop(0.6, `rgba(127,29,29,${0.5 + intensity * 0.4})`);
    gradient.addColorStop(1, "rgba(15,23,42,0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(0, 0, radius, 0, Math.PI * 2);
    ctx.fill();

    const drawBlock = (x, y, w, h, color) => {
      ctx.fillStyle = color;
      ctx.fillRect(x * pixel, y * pixel, w * pixel, h * pixel);
    };

    const bodyCol = "#111827";
    const highlightCol = "#1f2937";

    for (let row = -6; row <= 6; row++) {
      const width = row < 0 ? 6 + row : 6 - row * 0.7;
      for (let col = -width; col <= width; col++) {
        const c = Math.random() > 0.75 ? highlightCol : bodyCol;
        drawBlock(col, row, 1, 1, c);
      }
    }

    drawBlock(-5, -7, 2, 3, "#000000");
    drawBlock(3, -7, 2, 3, "#000000");

    ctx.shadowColor = "#f97316";
    ctx.shadowBlur = 12 + intensity * 12;
    drawBlock(-3, -3, 2, 2, "#f97316");
    drawBlock(2, -3, 2, 2, "#f97316");
    ctx.shadowBlur = 0;

    drawBlock(-2, -2, 1, 1, "#ffffff");
    drawBlock(3, -2, 1, 1, "#ffffff");

    for (let i = -3; i <= 3; i++) {
      const h = i % 2 === 0 ? 2 : 1;
      drawBlock(i, 2, 1, h, "#ef4444");
    }

    ctx.restore();
  }

  function drawPixelPlayer() {
    const p = game.player;
    const height = p.isSliding ? PLAYER_SLIDE_HEIGHT : PLAYER_HEIGHT;
    const pixel = 4;

    ctx.save();
    ctx.translate(p.x + PLAYER_WIDTH / 2, p.y + height / 2);

    if (p.isSliding) {
      ctx.rotate(-Math.PI / 12);
      ctx.scale(1.1, 0.7);
    }

    if (game.hasKestrlCard) {
      ctx.shadowColor = "#22c55e";
      ctx.shadowBlur = 18;
    }

    const runFrame = Math.floor(game.frameCount / 6) % 4;
    const wingFrame = p.isJumping ? 2 : runFrame;
    const legOffset = [0, -1, 0, 1][runFrame];

    const cols = {
      bodyDark: "#5c3d2e",
      bodyMid: "#8b5e3c",
      bodyLight: "#a67c52",
      wingDark: "#4a2d1a",
      wingMid: "#6b4423",
      head: "#0ea5e9",
      beak: game.hasKestrlCard ? "#22c55e" : "#eab308",
      beakLight: game.hasKestrlCard ? "#86efac" : "#facc15",
      eye: "#000000",
      eyeShine: "#ffffff",
      outline: "#111827",
    };

    const drawPx = (x, y, w, h, color) => {
      ctx.fillStyle = color;
      ctx.fillRect(x * pixel, y * pixel, w * pixel, h * pixel);
    };

    drawPx(-6, -6, 13, 11, cols.outline);

    drawPx(-5, -5, 11, 9, cols.bodyMid);
    drawPx(-5, -5, 9, 3, cols.bodyLight);
    drawPx(-5, 1, 11, 3, cols.bodyDark);

    const wingY = [-3, -4, -5, -4][wingFrame];
    drawPx(-4, wingY, 6, 4, cols.wingDark);
    drawPx(-3, wingY, 4, 2, cols.wingMid);

    drawPx(4, -7, 6, 6, cols.head);
    drawPx(4, -7, 5, 2, "#38bdf8");

    drawPx(7, -6, 2, 2, cols.eye);
    drawPx(8, -6, 1, 1, cols.eyeShine);

    drawPx(10, -5, 3, 1, cols.beak);
    drawPx(11, -4, 2, 1, cols.beakLight);

    drawPx(-7, -1, 2, 1, cols.wingMid);
    drawPx(-8, 0, 2, 1, cols.wingDark);
    drawPx(-9, 1, 2, 1, cols.wingMid);

    if (!p.isSliding) {
      const leg1Y = 3 + legOffset;
      const leg2Y = 3 - legOffset;
      drawPx(-1, leg1Y, 1, 3, cols.beak);
      drawPx(2, leg2Y, 1, 3, cols.beak);
    }

    ctx.shadowBlur = 0;
    ctx.restore();
  }

  // ---------- DRAW MAP ----------
  function drawWorldMap() {
    ctx.save();
    ctx.imageSmoothingEnabled = false;

    const w = canvas.width;
    const h = canvas.height;

    // dark outer vignette
    const outer = ctx.createRadialGradient(
      w / 2,
      h / 2,
      Math.min(w, h) * 0.15,
      w / 2,
      h / 2,
      Math.max(w, h) * 0.75
    );
    outer.addColorStop(0, "#111827");
    outer.addColorStop(1, "#020617");
    ctx.fillStyle = outer;
    ctx.fillRect(0, 0, w, h);

    // parchment panel
    const margin = Math.min(w, h) * 0.08;
    const x = margin;
    const y = margin;
    const pw = w - margin * 2;
    const ph = h - margin * 2;

    const parchment = ctx.createLinearGradient(0, y, 0, y + ph);
    parchment.addColorStop(0, "#fdf0c6");
    parchment.addColorStop(0.4, "#f4cf8a");
    parchment.addColorStop(1, "#eab768");
    ctx.fillStyle = parchment;
    ctx.fillRect(x, y, pw, ph);

    // texture blotches
    ctx.globalAlpha = 0.18;
    ctx.fillStyle = "#b98a4b";
    for (let i = 0; i < 50; i++) {
      const bx = x + Math.random() * pw;
      const by = y + Math.random() * ph;
      const br = Math.random() * 40 + 10;
      ctx.beginPath();
      ctx.ellipse(bx, by, br, br * 0.6, Math.random() * Math.PI, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;

    // borders
    ctx.strokeStyle = "#7c2d12";
    ctx.lineWidth = 6;
    ctx.strokeRect(x, y, pw, ph);

    ctx.strokeStyle = "#451a03";
    ctx.lineWidth = 2;
    ctx.strokeRect(x + 10, y + 10, pw - 20, ph - 20);

    // corner flourishes
    ctx.strokeStyle = "#7f1d1d";
    ctx.lineWidth = 1.5;
    const flourish = (fx, fy, dirX, dirY) => {
      ctx.beginPath();
      ctx.moveTo(fx, fy);
      ctx.quadraticCurveTo(fx + 40 * dirX, fy, fx + 50 * dirX, fy + 30 * dirY);
      ctx.quadraticCurveTo(
        fx + 35 * dirX,
        fy + 45 * dirY,
        fx + 10 * dirX,
        fy + 55 * dirY
      );
      ctx.stroke();
    };
    flourish(x + 22, y + 22, 1, 1);
    flourish(x + pw - 22, y + 22, -1, 1);
    flourish(x + 22, y + ph - 22, 1, -1);
    flourish(x + pw - 22, y + ph - 22, -1, -1);

    // title & lore
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    ctx.fillStyle = "#1f2937";
    ctx.font = "bold 46px 'Times New Roman', serif";
    ctx.fillText("HALAL REALM", w / 2, y + 18);

    ctx.font = "18px 'Times New Roman', serif";
    ctx.fillStyle = "#374151";
    ctx.fillText("Click a kingdom to cleanse its markets.", w / 2, y + 70);

    ctx.font = "16px 'Times New Roman', serif";
    ctx.fillStyle = "#4b5563";
    ctx.fillText(
      "Begin in the Kingdom of Syarmin and confront Riba.",
      w / 2,
      y + 98
    );

    // landmasses
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(x + pw * 0.13, y + ph * 0.30);
    ctx.lineTo(x + pw * 0.30, y + ph * 0.25);
    ctx.lineTo(x + pw * 0.42, y + ph * 0.32);
    ctx.lineTo(x + pw * 0.48, y + ph * 0.42);
    ctx.lineTo(x + pw * 0.40, y + ph * 0.55);
    ctx.lineTo(x + pw * 0.24, y + ph * 0.56);
    ctx.lineTo(x + pw * 0.11, y + ph * 0.47);
    ctx.closePath();
    ctx.fillStyle = "rgba(148, 123, 89, 0.55)";
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(x + pw * 0.55, y + ph * 0.28);
    ctx.lineTo(x + pw * 0.80, y + ph * 0.28);
    ctx.lineTo(x + pw * 0.88, y + ph * 0.40);
    ctx.lineTo(x + pw * 0.84, y + ph * 0.60);
    ctx.lineTo(x + pw * 0.60, y + ph * 0.64);
    ctx.lineTo(x + pw * 0.52, y + ph * 0.48);
    ctx.closePath();
    ctx.fill();

    // mountains
    ctx.strokeStyle = "#4b5563";
    ctx.lineWidth = 1.3;
    const drawMountains = (startX, startY, count, dir) => {
      for (let i = 0; i < count; i++) {
        const mx = startX + i * 14 * dir + (Math.random() * 4 - 2);
        const my = startY + (Math.random() * 6 - 3);
        ctx.beginPath();
        ctx.moveTo(mx - 5, my + 5);
        ctx.lineTo(mx, my - 6);
        ctx.lineTo(mx + 5, my + 5);
        ctx.stroke();
      }
    };
    drawMountains(x + pw * 0.18, y + ph * 0.40, 10, 1);
    drawMountains(x + pw * 0.65, y + ph * 0.38, 9, 1);
    drawMountains(x + pw * 0.44, y + ph * 0.52, 7, -1);

    // rivers
    ctx.strokeStyle = "#2563eb";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x + pw * 0.50, y + ph * 0.30);
    ctx.bezierCurveTo(
      x + pw * 0.47, y + ph * 0.38,
      x + pw * 0.55, y + ph * 0.48,
      x + pw * 0.52, y + ph * 0.60
    );
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(x + pw * 0.30, y + ph * 0.33);
    ctx.bezierCurveTo(
      x + pw * 0.26, y + ph * 0.38,
      x + pw * 0.22, y + ph * 0.50,
      x + pw * 0.24, y + ph * 0.60
    );
    ctx.stroke();
    ctx.restore();

    // compass (top-right)
    const compassR = Math.min(pw, ph) * 0.06;
    const cxComp = x + pw - compassR - 30;
    const cyComp = y + compassR + 30;

    const compGrad = ctx.createRadialGradient(
      cxComp,
      cyComp,
      0,
      cxComp,
      cyComp,
      compassR
    );
    compGrad.addColorStop(0, "#fefce8");
    compGrad.addColorStop(1, "#fbbf24");
    ctx.fillStyle = compGrad;
    ctx.beginPath();
    ctx.arc(cxComp, cyComp, compassR, 0, Math.PI * 2);
    ctx.fill();

    ctx.strokeStyle = "#7c2d12";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cxComp, cyComp, compassR, 0, Math.PI * 2);
    ctx.moveTo(cxComp - compassR + 6, cyComp);
    ctx.lineTo(cxComp + compassR - 6, cyComp);
    ctx.moveTo(cxComp, cyComp - compassR + 6);
    ctx.lineTo(cxComp, cyComp + compassR - 6);
    ctx.stroke();

    ctx.fillStyle = "#7c2d12";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.font = "12px 'Times New Roman', serif";
    ctx.fillText("QIBLA", cxComp, cyComp + compassR + 12);

    // kingdoms
    const regions = getMapRegions();

    regions.forEach((region) => {
      const { cx, cy, rx, ry, status, name, subtitle, id } = region;

      const pulse = Math.sin(game.frameCount * 0.05 + (id === "riba" ? 0 : 2)) * 4;
      const drawRx = rx + (id === "riba" ? pulse : 0);
      const drawRy = ry + (id === "riba" ? pulse * 0.6 : 0);

      // glow for unlocked only
      if (status === "unlocked") {
        const glow = ctx.createRadialGradient(cx, cy, 0, cx, cy, drawRx * 1.2);
        glow.addColorStop(0, "rgba(248,250,252,0.9)");
        glow.addColorStop(1, "rgba(248,250,252,0)");
        ctx.fillStyle = glow;
        ctx.beginPath();
        ctx.ellipse(cx, cy, drawRx * 1.2, drawRy * 1.2, 0, 0, Math.PI * 2);
        ctx.fill();
      }

      // island base
      const grad = ctx.createLinearGradient(cx, cy - drawRy, cx, cy + drawRy);
      if (status === "unlocked") {
        grad.addColorStop(0, "#fed7aa");
        grad.addColorStop(1, "#f97316");
      } else {
        grad.addColorStop(0, "#e5e7eb");
        grad.addColorStop(1, "#9ca3af");
      }
      ctx.fillStyle = grad;
      ctx.strokeStyle = status === "unlocked" ? "#b45309" : "#6b7280";
      ctx.lineWidth = status === "unlocked" ? 3 : 2;
      ctx.beginPath();
      ctx.ellipse(cx, cy, drawRx, drawRy, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // tower marker
      ctx.save();
      ctx.translate(cx, cy - drawRy * 0.25);
      ctx.fillStyle = status === "unlocked" ? "#7c2d12" : "#4b5563";
      ctx.fillRect(-6, -12, 12, 22);
      ctx.beginPath();
      ctx.moveTo(-7, -11);
      ctx.lineTo(0, -22);
      ctx.lineTo(7, -11);
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      // label banner
      const panelW = 260;
      const panelH = 60;
      const panelY = cy + drawRy + 12;

      ctx.fillStyle = "#020617";
      ctx.fillRect(cx - panelW / 2, panelY, panelW, panelH);
      ctx.strokeStyle = status === "unlocked" ? "#f97316" : "#6b7280";
      ctx.lineWidth = 2;
      ctx.strokeRect(cx - panelW / 2, panelY, panelW, panelH);

      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.font = "16px monospace";
      ctx.fillStyle = "#f9fafb";
      ctx.fillText(name.toUpperCase(), cx, panelY + 6);

      ctx.font = "13px monospace";
      ctx.fillStyle = "#e5e7eb";
      ctx.fillText(subtitle, cx, panelY + 24);

      ctx.fillStyle = status === "unlocked" ? "#bbf7d0" : "#fecaca";
      const statusText =
        status === "unlocked" ? "Click to enter" : "Locked · Coming soon";
      ctx.fillText(statusText, cx, panelY + 40);
    });

    // bottom tip
    ctx.textAlign = "center";
    ctx.textBaseline = "bottom";
    ctx.font = "14px monospace";
    ctx.fillStyle = "#4b5563";
    ctx.fillText(
      "Tip: Press SPACE or ENTER to jump straight into the Kingdom of Syarmin",
      w / 2,
      y + ph - 12
    );

    ctx.restore();
  }

  // ---------- DRAW MAIN ----------
  function draw() {
    ctx.save();
    ctx.imageSmoothingEnabled = false;

    if (game.state === "map") {
      drawWorldMap();
      ctx.restore();
      return;
    }

    if (game.glitchIntensity > 0.25) {
      const s = game.glitchIntensity * 5;
      ctx.translate(
        (Math.random() - 0.5) * s,
        (Math.random() - 0.5) * s
      );
    }

    const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
    sky.addColorStop(0, "#5c94fc");
    sky.addColorStop(1, "#1e40af");
    ctx.fillStyle = sky;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.fillStyle = "#eff6ff";
    for (let i = 0; i < 40; i++) {
      const x = (i * 173 + game.frameCount * 0.1) % canvas.width;
      const y = (i * 97) % (game.groundY - 60);
      ctx.fillRect(Math.floor(x), Math.floor(y), 1, 1);
    }

    ctx.fillStyle = "#1e3a8a";
    ctx.beginPath();
    ctx.moveTo(0, canvas.height);
    ctx.lineTo(canvas.width * 0.25, game.groundY - 40);
    ctx.lineTo(canvas.width * 0.5, canvas.height);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "#1d4ed8";
    ctx.beginPath();
    ctx.moveTo(canvas.width * 0.4, canvas.height);
    ctx.lineTo(canvas.width * 0.7, game.groundY - 50);
    ctx.lineTo(canvas.width, canvas.height);
    ctx.closePath();
    ctx.fill();

    const tile = 32;
    for (let x = 0; x < canvas.width + tile; x += tile) {
      ctx.fillStyle = "#f97316";
      ctx.fillRect(x, game.groundY, tile, 16);
      ctx.fillStyle = "#ea580c";
      ctx.fillRect(x, game.groundY + 16, tile, 16);
      ctx.fillStyle = "#9a3412";
      ctx.fillRect(x, game.groundY + 32, tile, GROUND_HEIGHT - 32);

      ctx.strokeStyle = "#7c2d12";
      ctx.lineWidth = 2;
      ctx.strokeRect(x, game.groundY, tile, GROUND_HEIGHT);
    }

    if (game.monster.x < canvas.width + 200) {
      drawPixelMonster();
    }

    game.obstacles.forEach((obs) => {
      ctx.fillStyle = "#6d28d9";
      ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
      ctx.strokeStyle = "#4c1d95";
      ctx.lineWidth = 2;
      ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);
    });

    game.powerUps.forEach((pu) => {
      const t = Math.sin(pu.pulsePhase) * 1.5;
      ctx.save();
      ctx.translate(pu.x + pu.width / 2, pu.y + pu.height / 2);

      const w = pu.width + t * 2;
      const h = pu.height;

      const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, w);
      glow.addColorStop(0, "rgba(56,189,248,0.8)");
      glow.addColorStop(1, "rgba(56,189,248,0)");
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(0, 0, w, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#0ea5e9";
      ctx.fillRect(-w / 2, -h / 2, w, h);
      ctx.strokeStyle = "#38bdf8";
      ctx.lineWidth = 3;
      ctx.strokeRect(-w / 2, -h / 2, w, h);

      ctx.fillStyle = "#e5e7eb";
      ctx.font = "bold 16px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("K", 0, 0);

      ctx.restore();
    });

    game.coins.forEach((coin) => {
      const px = 4;
      const baseSize = 4;
      const pulse = Math.sin(coin.pulsePhase) * 0.5;
      const s = baseSize + pulse;

      const glowRadius = s * px * 3;
      const glow = ctx.createRadialGradient(
        coin.x,
        coin.y,
        0,
        coin.x,
        coin.y,
        glowRadius
      );
      if (game.hasKestrlCard) {
        glow.addColorStop(0, "rgba(45,212,191,0.8)");
        glow.addColorStop(1, "rgba(45,212,191,0)");
      } else if (coin.isGreen) {
        glow.addColorStop(0, "rgba(250,204,21,0.8)");
        glow.addColorStop(1, "rgba(250,204,21,0)");
      } else {
        glow.addColorStop(0, "rgba(248,113,113,0.8)");
        glow.addColorStop(1, "rgba(248,113,113,0)");
      }
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(coin.x, coin.y, glowRadius, 0, Math.PI * 2);
      ctx.fill();

      const sizePx = s * px;
      const x = Math.round(coin.x - sizePx / 2);
      const y = Math.round(coin.y - sizePx / 2);

      ctx.fillStyle = game.hasKestrlCard
        ? "#22c55e"
        : coin.isGreen
        ? "#facc15"
        : "#ef4444";
      ctx.fillRect(x, y, sizePx, sizePx);

      ctx.strokeStyle = coin.isGreen ? "#92400e" : "#7f1d1d";
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, sizePx, sizePx);

      ctx.fillStyle = "#111827";
      ctx.font = "bold 12px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(coin.isGreen ? "$" : "!", coin.x, coin.y);

      ctx.font = "12px monospace";
      if (game.hasKestrlCard || coin.isGreen) {
        ctx.fillStyle = "#bbf7d0";
        ctx.fillText("+10", coin.x, coin.y + sizePx / 2 + 12);
      } else {
        ctx.fillStyle = "#fecaca";
        ctx.fillText("-50", coin.x, coin.y + sizePx / 2 + 12);
      }
    });

    drawPixelPlayer();

    game.particles.forEach((p2) => {
      ctx.globalAlpha = p2.life;
      ctx.fillStyle = p2.color;
      ctx.fillRect(
        Math.floor(p2.x),
        Math.floor(p2.y),
        Math.max(2, p2.size),
        Math.max(2, p2.size)
      );
    });
    ctx.globalAlpha = 1;

    if (game.glitchIntensity > 0) {
      const t = game.glitchIntensity;
      ctx.fillStyle = `rgba(148,27,27,${0.2 * t})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < canvas.height; y += 3) {
        ctx.fillStyle = `rgba(0,0,0,${0.1 + 0.15 * t})`;
        ctx.fillRect(0, y, canvas.width, 1);
      }

      const noiseCount = 40 * t;
      for (let i = 0; i < noiseCount; i++) {
        const nx = Math.random() * canvas.width;
        const ny = Math.random() * canvas.height;
        ctx.fillStyle =
          Math.random() > 0.5
            ? "rgba(220,38,38,0.8)"
            : "rgba(15,23,42,0.8)";
        ctx.fillRect(nx, ny, 2, 2);
      }
    }

    drawHUD();

    ctx.restore();
  }

  // ---------- HUD ----------
  function drawHUD() {
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.font = "16px monospace";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";

    ctx.fillStyle = "#020617";
    ctx.fillRect(16, 16, 160, 46);
    ctx.strokeStyle = game.score >= 0 ? "#facc15" : "#ef4444";
    ctx.lineWidth = 3;
    ctx.strokeRect(16, 16, 160, 46);
    ctx.fillStyle = "#9ca3af";
    ctx.fillText("SCORE", 24, 22);
    ctx.fillStyle = game.score >= 0 ? "#facc15" : "#f97316";
    ctx.font = "bold 20px monospace";
    ctx.fillText(Math.floor(game.score).toString(), 24, 38);

    ctx.font = "16px monospace";
    ctx.fillStyle = "#020617";
    ctx.fillRect(16, 72, 140, 38);
    ctx.strokeStyle = "#38bdf8";
    ctx.strokeRect(16, 72, 140, 38);
    ctx.fillStyle = "#9ca3af";
    ctx.fillText("DIST", 24, 78);
    ctx.fillStyle = "#e5e7eb";
    ctx.fillText(game.distance.toString() + "m", 24, 92);

    const spX = canvas.width - 180;
    ctx.fillStyle = "#022c22";
    ctx.fillRect(spX, 16, 164, 46);
    ctx.strokeStyle = "#22c55e";
    ctx.strokeRect(spX, 16, 164, 46);
    ctx.fillStyle = "#6ee7b7";
    ctx.fillText("SAVED (S)", spX + 8, 22);
    ctx.fillStyle = "#bbf7d0";
    ctx.font = "bold 20px monospace";
    ctx.fillText(game.savingsPot.toString(), spX + 8, 38);

    ctx.font = "14px monospace";
    ctx.fillStyle = "#020617";
    ctx.fillRect(spX, 72, 164, 38);
    ctx.strokeStyle = "#4b5563";
    ctx.strokeRect(spX, 72, 164, 38);
    ctx.fillStyle = "#facc15";
    ctx.fillText("HALAL: " + game.greenCoins, spX + 8, 78);
    ctx.fillStyle = "#fca5a5";
    ctx.fillText("RIBA: " + game.redCoins, spX + 8, 94);

    const barX = canvas.width / 2 - 180;
    const barY = 20;
    const barW = 360;
    const barH = 22;

    ctx.fillStyle = "#020617";
    ctx.fillRect(barX, barY, barW, barH);
    ctx.strokeStyle = "#9ca3af";
    ctx.strokeRect(barX, barY, barW, barH);

    const ratio = game.necessityMeter / 100;
    const color =
      ratio > 0.6 ? "#22c55e" : ratio > 0.3 ? "#eab308" : "#ef4444";
    ctx.fillStyle = color;
    ctx.fillRect(barX + 2, barY + 2, (barW - 4) * Math.max(0, ratio), barH - 4);

    ctx.fillStyle = "#e5e7eb";
    ctx.font = "12px monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(
      "NECESSITY " + Math.round(game.necessityMeter) + "%",
      barX + barW / 2,
      barY + barH / 2
    );

    if (game.hasKestrlCard) {
      const secs = Math.ceil(game.kestrlCardTimer / 60);
      ctx.font = "14px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillStyle = "#020617";
      ctx.fillRect(canvas.width / 2 - 80, 56, 160, 32);
      ctx.strokeStyle = "#06b6d4";
      ctx.strokeRect(canvas.width / 2 - 80, 56, 160, 32);
      ctx.fillStyle = "#67e8f9";
      ctx.fillText("KESTRL CARD: " + secs + "s", canvas.width / 2, 62);
    }

    if (game.state === "gameover") {
      ctx.fillStyle = "rgba(15,23,42,0.7)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = "32px monospace";
      ctx.fillStyle = "#f87171";
      ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 40);

      ctx.font = "18px monospace";
      ctx.fillStyle = "#e5e7eb";
      ctx.fillText(
        "Final score: " + Math.floor(game.score),
        canvas.width / 2,
        canvas.height / 2
      );
      ctx.fillText(
        "Press SPACE / TAP to restart",
        canvas.width / 2,
        canvas.height / 2 + 40
      );
    }

    ctx.restore();
  }

  // ---------- LOOP ----------
  function gameLoop() {
    update();
    draw();
    animationId = requestAnimationFrame(gameLoop);
  }
</script>
</body>
</html>











    


