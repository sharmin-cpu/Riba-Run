<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Riba Run – Map & Minigame</title>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      height: 100vh;
      background: #020617;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
      overflow: hidden;
    }

    /* =========================
       MAP SCREEN
       ========================= */
    #map-screen {
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .map-container {
      position: relative;
      width: 90vw;
      max-width: 1200px;
      aspect-ratio: 16 / 9;
      overflow: hidden;
      border-radius: 22px;
      box-shadow: 0 0 40px rgba(0,0,0,0.8);
    }

    /* your actual fantasy map image */
    .map {
      width: 100%;
      height: 100%;
      background-image: url("img:fantasy-world-map.png");
      background-size: cover;
      background-position: center;
      filter: brightness(1.05) contrast(1.08);
    }

    /* glowing clickable areas */
    .area {
      position: absolute;
      width: 70px;
      height: 70px;
      border-radius: 999px;
      cursor: pointer;

      background: radial-gradient(circle, rgba(56,189,248,0.45), rgba(56,189,248,0));
      border: 2px solid rgba(191,219,254,0.95);
      box-shadow:
        0 0 0 0 rgba(56,189,248,0.7),
        0 0 30px rgba(56,189,248,0.6);

      display: flex;
      align-items: center;
      justify-content: center;
      color: #e5f4ff;
      font-weight: 700;
      font-size: 20px;
      text-shadow: 0 0 6px #020617;

      transition: all 0.18s ease-out;
      animation: pulse 2.2s infinite;
      z-index: 2;
    }

    @keyframes pulse {
      0%   { box-shadow: 0 0 0 0 rgba(56,189,248,0.7); }
      70%  { box-shadow: 0 0 0 18px rgba(56,189,248,0); }
      100% { box-shadow: 0 0 0 0 rgba(56,189,248,0); }
    }

    .area:hover {
      transform: scale(1.12) translateY(-2px);
      background: radial-gradient(circle, rgba(56,189,248,0.7), rgba(56,189,248,0));
      box-shadow:
        0 0 0 8px rgba(56,189,248,0.45),
        0 0 60px rgba(56,189,248,1);
    }

    .area span {
      position: absolute;
      top: 82px;
      left: 50%;
      transform: translateX(-50%);
      white-space: nowrap;
      font-size: 14px;
      color: #e5e7eb;
      text-shadow: 0 0 6px #020617;
      pointer-events: none;
    }

    /* positions on your map */
    .area--castle   { top: 72%; left: 22%; }
    .area--forest   { top: 52%; left: 48%; }
    .area--cave     { top: 40%; left: 78%; }
    .area--villages { top: 76%; left: 69%; }

    /* =========================
       GAME SCREEN
       ========================= */
    #game-screen {
      display: none;
      height: 100vh;
      justify-content: center;
      align-items: center;
      background: #111;
    }

    #game-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-top: 10px;
      height: 100vh;
    }

    canvas {
      border: 2px solid #444;
      image-rendering: pixelated;
      background: #000;
    }

    #hud {
      margin-top: 8px;
      font-size: 14px;
      text-align: center;
      line-height: 1.4;
    }

    #game-over-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.85);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10;
    }

    #game-over-box {
      background: #1a1a1a;
      border: 2px solid #555;
      padding: 20px;
      border-radius: 8px;
      text-align: center;
      max-width: 360px;
    }

    #toast {
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.85);
      padding: 8px 12px;
      border-radius: 4px;
      display: none;
      z-index: 20;
    }
  </style>
</head>

<body>

  <!-- =======================
       MAP SCREEN
       ======================= -->
  <div id="map-screen">
    <div class="map-container">
      <div class="map"></div>

      <div class="area area--castle">1 <span>Castle Hub</span></div>
      <div class="area area--forest">2 <span>Forest Trials</span></div>
      <div class="area area--cave">3 <span>Riba Cave</span></div>
      <div class="area area--villages">4 <span>Market Town</span></div>
    </div>
  </div>


  <!-- =======================
       GAME SCREEN
       ======================= -->
  <div id="game-screen">
    <div id="game-wrapper">
      <canvas id="game" width="800" height="450"></canvas>
      <div id="hud">
        <strong>Controls:</strong> Arrow keys | S = Sadaqah | R = Restart
        <div id="stats"></div>
      </div>
    </div>

    <div id="game-over-overlay">
      <div id="game-over-box">
        <h2 id="game-over-title"></h2>
        <p id="game-over-message"></p>
        <button class="btn-secondary" id="btn-restart">Restart</button>
        <button class="btn-danger" id="btn-loan">Take Riba Loan</button>
      </div>
    </div>
  </div>

  <div id="toast"></div>


  <!-- ================================================================
       FULL RIBA RUN GAME IMPLEMENTATION (ENTIRE CODE MERGED IN)
       ================================================================ -->
  <script>
    /* MAP → GAME TRANSITION */
    const mapScreen  = document.getElementById('map-screen');
    const gameScreen = document.getElementById('game-screen');

    document.querySelectorAll('.area').forEach(area => {
      area.addEventListener('click', () => {
        mapScreen.style.display = 'none';
        gameScreen.style.display = 'flex';
        startRibaRun();
      });
    });

    /* ============================
       FULL GAME CODE STARTS HERE
       ============================ */

    let ribaStarted = false;

    function startRibaRun() {
      if (ribaStarted) return;
      ribaStarted = true;

      /* Your entire 2D Riba Run minigame */
      (function() {
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');

        const LOGICAL_WIDTH = 200;
        const LOGICAL_HEIGHT = 112;
        const SCALE = 4;
        canvas.width = LOGICAL_WIDTH * SCALE;
        canvas.height = LOGICAL_HEIGHT * SCALE;

        ctx.imageSmoothingEnabled = false;
        ctx.setTransform(SCALE, 0, 0, SCALE, 0, 0);

        const statsDiv = document.getElementById('stats');
        const overlay = document.getElementById('game-over-overlay');
        const toast = document.getElementById('toast');

        const btnRestart = document.getElementById('btn-restart');
        const btnLoan = document.getElementById('btn-loan');
        const gameOverTitle = document.getElementById('game-over-title');
        const gameOverMessage = document.getElementById('game-over-message');

        const LANES = 3;
        const laneYs = [40, 60, 80];
        const PLAYER_X = 40;
        const PLAYER_W = 10;
        const PLAYER_H = 8;

        const MONSTER_W = 14;
        const MONSTER_H = 12;

        const ITEM_W = 6;
        const ITEM_H = 6;

        const BASE_SPEED = 1.4;
        const SPEED_INC = 0.0001;

        const BALANCE_START = 500;
        const DRAIN_PER_FRAME_BASE = 1;
        const DRAIN_PER_FRAME_LOAN_MULTIPLIER = 2;

        const GREEN_VALUE = 10;
        const RED_VALUE = 50;

        const SADAQAH_COST = 100;
        const SADAQAH_DURATION_FRAMES = 900;

        const KESTRL_DURATION_FRAMES = 600;

        const INVEST_COST = 200;
        const INVEST_PAYOFF = 600;
        const INVEST_DELAY_FRAMES = 600;

        const MONSTER_START_DISTANCE = 120;
        const MONSTER_GAIN_PER_FRAME = 0.05;
        const MONSTER_GREEN_PUSH_BACK = 6;
        const MONSTER_RED_PULL = 10;
        const MONSTER_LOAN_EXTRA_PULL = 0.12;

        const FRAME_TIME = 1000 / 60;

        let playerLane, balance, drainPerFrame, baseDrainPerFrame;
        let monsterDistance;
        let items;
        let investments;
        let speed;
        let frameCount;
        let barakahActive, barakahTimer;
        let kestrlActive, kestrlTimer;
        let worldBright;
        let monsterBanished;
        let loanTaken;
        let running;
        let lastTime;
        let spawnTimer;
        let toastTimer = 0;
        let gameOver = false;
        let hardModeLoan = false;
        let fogLevel = 0.4;

        function resetGame() {
          playerLane = 1;
          balance = BALANCE_START;
          baseDrainPerFrame = DRAIN_PER_FRAME_BASE;
          drainPerFrame = baseDrainPerFrame;
          monsterDistance = MONSTER_START_DISTANCE;
          items = [];
          investments = [];
          speed = BASE_SPEED;
          frameCount = 0;
          barakahActive = false;
          barakahTimer = 0;
          kestrlActive = false;
          kestrlTimer = 0;
          worldBright = false;
          monsterBanished = false;
          loanTaken = false;
          running = true;
          lastTime = performance.now();
          spawnTimer = 0;
          toastTimer = 0;
          gameOver = false;
          hardModeLoan = false;
          fogLevel = 0.4;
          overlay.style.display = 'none';
        }

        function showToast(msg) {
          toast.innerText = msg;
          toast.style.display = 'block';
          toastTimer = 120;
        }

        function triggerGameOver(reason) {
          running = false;
          gameOver = true;

          if (reason === 'balance') {
            gameOverTitle.innerText = 'Bankruptcy';
            gameOverMessage.innerText =
              'Your balance hit £0. The Riba Monster is looming over you.';
          } else if (reason === 'caught') {
            gameOverTitle.innerText = 'Caught by Riba';
            gameOverMessage.innerText =
              'The Riba Monster caught you.';
          }

          overlay.style.display = 'flex';
        }

        function takeLoan() {
          if (!gameOver) return;
          balance += 1000;
          baseDrainPerFrame *= DRAIN_PER_FRAME_LOAN_MULTIPLIER;
          drainPerFrame = baseDrainPerFrame;
          monsterDistance = 25;
          loanTaken = true;
          hardModeLoan = true;
          gameOver = false;
          running = true;
          overlay.style.display = 'none';
        }

        btnRestart.addEventListener('click', resetGame);
        btnLoan.addEventListener('click', takeLoan);

        const keys = {};
        window.addEventListener('keydown', (e) => {
          keys[e.key] = true;

          if (e.key === 'ArrowUp') {
            playerLane = Math.max(0, playerLane - 1);
          } else if (e.key === 'ArrowDown') {
            playerLane = Math.min(LANES - 1, playerLane + 1);
          } else if (e.key === 's' || e.key === 'S') {
            activateSadaqah();
          } else if (e.key === 'r' || e.key === 'R') {
            resetGame();
          }
        });

        window.addEventListener('keyup', (e) => {
          keys[e.key] = false;
        });

        function activateSadaqah() {
          if (barakahActive) return showToast('Barakah already active.');
          if (balance < SADAQAH_COST) return showToast('Not enough balance.');
          balance -= SADAQAH_COST;
          barakahActive = true;
          barakahTimer = SADAQAH_DURATION_FRAMES;
          fogLevel = 0.1;
          showToast('Barakah x2 activated.');
        }

        function spawnItem() {
          const lane = Math.floor(Math.random() * LANES);
          const x = LOGICAL_WIDTH + 10;

          const roll = Math.random();
          let type;

          if (roll < 0.55) {
            type = Math.random() < 0.6 ? 'green' : 'red';
          } else if (roll < 0.7) {
            type = 'obstacle';
          } else if (roll < 0.84) {
            type = 'invest';
          } else {
            type = 'kestrl';
          }

          if (kestrlActive && type === 'red') {
            type = 'green';
          }

          items.push({ type, x, lane, w: ITEM_W, h: ITEM_H });
        }

        function update(delta) {
          if (!running) return;

          const frames = delta / FRAME_TIME;
          const effectiveFrames = Math.min(frames, 2);

          for (let i = 0; i < effectiveFrames; i++) {
            logicStep();
          }
        }

        function logicStep() {
          frameCount++;

          balance -= drainPerFrame;
          if (balance <= 0) {
            balance = 0;
            return triggerGameOver('balance');
          }

          speed += SPEED_INC;
          spawnTimer++;
          const spawnInterval = Math.max(30, 80 - Math.floor(frameCount / 600));
          if (spawnTimer >= spawnInterval) {
            spawnItem();
            spawnTimer = 0;
          }

          if (barakahActive) {
            barakahTimer--;
            if (barakahTimer <= 0) {
              barakahActive = false;
              fogLevel = 0.4;
            }
          }

          if (kestrlActive) {
            kestrlTimer--;
            if (kestrlTimer <= 0) {
              kestrlActive = false;
              worldBright = false;
              monsterBanished = false;
            }
          }

          for (let i = investments.length - 1; i >= 0; i--) {
            investments[i].timer--;
            if (investments[i].timer <= 0) {
              balance += INVEST_PAYOFF;
              investments.splice(i, 1);
            }
          }

          if (!monsterBanished) {
            monsterDistance -= MONSTER_GAIN_PER_FRAME;
            if (loanTaken) monsterDistance -= MONSTER_LOAN_EXTRA_PULL;
            if (monsterDistance <= 0) {
              return triggerGameOver('caught');
            }
          }

          /* collision */
          for (let i = items.length - 1; i >= 0; i--) {
            const it = items[i];
            it.x -= speed;

            if (it.x < -20) {
              items.splice(i, 1);
              continue;
            }

            const px = PLAYER_X;
            const py = laneYs[playerLane] - PLAYER_H / 2;

            if (px < it.x + it.w &&
                px + PLAYER_W > it.x &&
                py < laneYs[it.lane] + it.h / 2 &&
                py + PLAYER_H > laneYs[it.lane] - it.h / 2) {

              if (it.type === 'green') {
                balance += barakahActive ? GREEN_VALUE * 2 : GREEN_VALUE;
                if (!monsterBanished) monsterDistance += 6;
              }
              else if (it.type === 'red') {
                balance += barakahActive ? RED_VALUE * 2 : RED_VALUE;
                if (!monsterBanished) monsterDistance -= 10;
              }
              else if (it.type === 'obstacle') {
                return triggerGameOver('caught');
              }
              else if (it.type === 'invest') {
                if (balance >= INVEST_COST) {
                  balance -= INVEST_COST;
                  investments.push({ timer: INVEST_DELAY_FRAMES });
                }
              }
              else if (it.type === 'kestrl') {
                kestrlActive = true;
                kestrlTimer = KESTRL_DURATION_FRAMES;
                monsterBanished = true;
                for (const o of items) if (o.type === 'red') o.type = 'green';
              }

              items.splice(i, 1);
            }
          }

          if (toastTimer > 0) {
            toastTimer--;
            if (toastTimer <= 0) toast.style.display = 'none';
          }
        }

        function drawBackground() {
          const grd = ctx.createLinearGradient(0, 0, 0, LOGICAL_HEIGHT);
          grd.addColorStop(0, 'rgba(0,0,0,1)');
          grd.addColorStop(1, `rgba(0,0,0,${1 - fogLevel})`);
          ctx.fillStyle = grd;
          ctx.fillRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);

          ctx.strokeStyle = worldBright ? 'rgba(120,255,180,0.4)' : 'rgba(0,255,150,0.25)';
          ctx.beginPath();
          for (let x = 0; x < LOGICAL_WIDTH; x += 10) {
            ctx.moveTo(x + (frameCount % 10), 0);
            ctx.lineTo(x + (frameCount % 10), LOGICAL_HEIGHT);
          }
          ctx.stroke();

          ctx.strokeStyle = 'rgba(255,255,255,0.12)';
          ctx.beginPath();
          for (let y of laneYs) {
            ctx.moveTo(0, y + 6);
            ctx.lineTo(LOGICAL_WIDTH, y + 6);
          }
          ctx.stroke();
        }

        function drawMonster() {
          const t = Math.max(0, Math.min(1, monsterDistance / MONSTER_START_DISTANCE));
          const x = 10 - (1 - t) * 6;
          const y = laneYs[playerLane] - MONSTER_H / 2;

          ctx.fillStyle = monsterBanished ?
            'rgba(255,0,0,0.15)' :
            'rgba(255,0,0,0.65)';

          ctx.fillRect(x, y, MONSTER_W, MONSTER_H);
        }

        function drawPlayer() {
          const px = PLAYER_X;
          const py = laneYs[playerLane] - PLAYER_H / 2;

          ctx.fillStyle = '#3b82f6';
          ctx.fillRect(px, py, PLAYER_W, PLAYER_H);
          ctx.fillStyle = '#fbbf24';
          ctx.fillRect(px + PLAYER_W, py + 2, 3, 3);
        }

        function drawItems() {
          for (const it of items) {
            const x = it.x;
            const y = laneYs[it.lane] - it.h / 2;

            if (it.type === 'green') {
              ctx.fillStyle = '#22c55e';
            } else if (it.type === 'red') {
              ctx.fillStyle = '#ef4444';
            } else if (it.type === 'obstacle') {
              ctx.fillStyle = '#9ca3af';
            } else if (it.type === 'invest') {
              ctx.fillStyle = '#facc15';
            } else if (it.type === 'kestrl') {
              ctx.fillStyle = '#38bdf8';
            }

            ctx.fillRect(x, y, it.w, it.h);
          }
        }

        function drawHUD() {
          statsDiv.textContent = `Balance: £${Math.floor(balance)} | Threat: ${Math.floor((1 - monsterDistance / MONSTER_START_DISTANCE)*100)}%`;
        }

        function draw() {
          drawBackground();
          drawItems();
          drawMonster();
          drawPlayer();
          drawHUD();
        }

        function loop(timestamp) {
          if (!lastTime) lastTime = timestamp;
          const delta = timestamp - lastTime;
          lastTime = timestamp;

          update(delta);
          draw();

          requestAnimationFrame(loop);
        }

        let investments = [];
        let items = [];
        resetGame();
        requestAnimationFrame(loop);

      })(); // end game
    } // end startRibaRun

  </script>
</body>
</html>
















    


