<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Riba Run – Pixel Retro Edition</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      overflow: hidden;
      background: #000000;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #gameCanvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
      touch-action: none;
    }
  </style>
</head>
<body onload="init()">
<canvas id="gameCanvas"></canvas>

<script>
  // ---------- CONSTANTS ----------
  const GROUND_HEIGHT = 100;
  const PLAYER_WIDTH = 48;
  const PLAYER_HEIGHT = 56;
  const PLAYER_SLIDE_HEIGHT = 28;
  const GRAVITY = 0.55;
  const JUMP_FORCE = -14;

  const INITIAL_SPEED = 4.5;
  const MAX_SPEED = 16;
  const BASE_SPEED_INCREMENT = 0.0012;
  const COYOTE_TIME = 8;

  // ---------- GAME STATE ----------
  const game = {
    state: "running",
    player: {
      x: 120,
      y: 0,
      velocityY: 0,
      isJumping: false,
      isSliding: false,
      slideTimer: 0,
    },
    obstacles: [],
    coins: [],
    powerUps: [],
    particles: [],
    parallaxLayers: [],
    monster: { x: -150, targetX: -150, size: 1 },
    coyoteCounter: 0,
    speed: INITIAL_SPEED,
    score: 0,
    greenCoins: 0,
    redCoins: 0,
    necessityMeter: 100,
    distance: 0,
    frameCount: 0,
    groundY: 0,
    hasKestrlCard: false,
    kestrlCardTimer: 0,
    debtThreshold: -150,
    glitchIntensity: 0,
    gameOverTime: 0,
    savingsPot: 0,
  };

  let canvas, ctx;
  let animationId;

  // ---------- INIT ----------
  function init() {
    canvas = document.getElementById("gameCanvas");
    ctx = canvas.getContext("2d");

    try {
      const saved = localStorage.getItem("ribaRunSavings");
      if (saved !== null) game.savingsPot = parseInt(saved, 10) || 0;
    } catch (e) {
      game.savingsPot = 0;
    }

    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    window.addEventListener("keydown", handleKeyDown);
    canvas.addEventListener("touchstart", handleTouch, { passive: false });

    gameLoop();
  }

  function resetRun() {
    game.state = "running";
    game.obstacles = [];
    game.coins = [];
    game.powerUps = [];
    game.particles = [];
    game.parallaxLayers = [
      { x: 0, speed: 0.2 },
      { x: 0, speed: 0.4 },
      { x: 0, speed: 0.6 },
    ];

    game.monster = { x: -150, targetX: -150, size: 1 };
    game.coyoteCounter = 0;
    game.speed = INITIAL_SPEED;
    game.score = 0;
    game.greenCoins = 0;
    game.redCoins = 0;
    game.necessityMeter = 100;
    game.distance = 0;
    game.frameCount = 0;
    game.hasKestrlCard = false;
    game.kestrlCardTimer = 0;
    game.glitchIntensity = 0;
    game.gameOverTime = 0;

    game.player.x = 120;
    game.player.y = game.groundY - PLAYER_HEIGHT;
    game.player.velocityY = 0;
    game.player.isJumping = false;
    game.player.isSliding = false;
    game.player.slideTimer = 0;
  }

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    game.groundY = canvas.height - GROUND_HEIGHT;
    if (game.state === "running") {
      game.player.y = game.groundY - PLAYER_HEIGHT;
    }
  }

  // ---------- INPUT ----------
  function handleKeyDown(e) {
    if (game.state === "gameover") {
      if (e.code === "Space" || e.code === "Enter") {
        resetRun();
      }
      return;
    }

    if (e.code === "Space" || e.code === "ArrowUp") {
      e.preventDefault();
      handleJump();
    } else if (e.code === "ArrowDown") {
      e.preventDefault();
      handleSlide();
    } else if (e.code === "KeyS") {
      e.preventDefault();
      handleSave();
    }
  }

  function handleTouch(e) {
    e.preventDefault();
    const touch = e.touches[0];
    if (game.state === "gameover") {
      resetRun();
      return;
    }
    if (touch.clientY > window.innerHeight / 2) {
      handleSlide();
    } else {
      handleJump();
    }
  }

  function handleJump() {
    const p = game.player;
    const canJump =
      (!p.isJumping || game.coyoteCounter > 0) &&
      !p.isSliding &&
      game.state === "running";
    if (canJump) {
      p.velocityY = JUMP_FORCE;
      p.isJumping = true;
      game.coyoteCounter = 0;
    }
  }

  function handleSlide() {
    const p = game.player;
    if (!p.isJumping && !p.isSliding && game.state === "running") {
      p.isSliding = true;
      p.slideTimer = 35;
    }
  }

  function handleSave() {
    if (game.state !== "running") return;
    if (game.score >= 10) {
      game.score -= 10;
      game.savingsPot += 10;
      try {
        localStorage.setItem("ribaRunSavings", String(game.savingsPot));
      } catch (e) {}

      createParticles(
        game.player.x + PLAYER_WIDTH / 2,
        game.player.y,
        "#22c55e",
        10
      );
    }
  }

  // ---------- SPAWN HELPERS ----------
  function spawnObstacle() {
    const types = ["low", "high", "double"];
    const type = types[Math.floor(Math.random() * types.length)];

    let obstacle = { x: canvas.width + 50, type, passed: false };

    if (type === "low") {
      obstacle.y = game.groundY - 45;
      obstacle.width = 35;
      obstacle.height = 45;
    } else if (type === "high") {
      obstacle.y = game.groundY - 90;
      obstacle.width = 45;
      obstacle.height = 35;
    } else {
      obstacle.y = game.groundY - 70;
      obstacle.width = 55;
      obstacle.height = 70;
    }

    game.obstacles.push(obstacle);
  }

  function spawnCoin() {
    const spawnGreen = Math.random() < 0.6;

    if (spawnGreen) {
      const positions = [
        { y: game.groundY - 120, count: 3 },
        { y: game.groundY - 90, count: 2 },
      ];
      const pos = positions[Math.floor(Math.random() * positions.length)];
      for (let i = 0; i < pos.count; i++) {
        game.coins.push({
          x: canvas.width + 60 + i * 40,
          y: pos.y,
          radius: 16,
          isGreen: true,
          pulsePhase: Math.random() * Math.PI * 2,
        });
      }
    } else {
      const count = Math.floor(Math.random() * 2) + 1;
      for (let i = 0; i < count; i++) {
        game.coins.push({
          x: canvas.width + 60 + i * 35,
          y: game.groundY - 40,
          radius: 14,
          isGreen: false,
          pulsePhase: Math.random() * Math.PI * 2,
        });
      }
    }
  }

  function spawnKestrlCard() {
    if (
      Math.random() < 0.25 &&
      !game.hasKestrlCard &&
      game.powerUps.length === 0
    ) {
      game.powerUps.push({
        x: canvas.width + 50,
        y: game.groundY - 90,
        width: 50,
        height: 32,
        pulsePhase: 0,
      });
    }
  }

  function createParticles(x, y, color, count) {
    const n = count || 10;
    for (let i = 0; i < n; i++) {
      game.particles.push({
        x,
        y,
        vx: (Math.random() - 0.5) * 6,
        vy: (Math.random() - 0.5) * 6,
        life: 1,
        color,
        size: Math.random() * 3 + 2,
      });
    }
  }

  // ---------- DEATH / REVIVE ----------
  function triggerDeath() {
    if (game.state !== "running") return;

    const finalScore = Math.floor(game.score);
    const currentDebt = finalScore < 0 ? finalScore : 0;
    const reviveCost = 50 + Math.abs(currentDebt);

    if (game.savingsPot >= reviveCost) {
      // revive using savings
      game.savingsPot -= reviveCost;
      try {
        localStorage.setItem("ribaRunSavings", String(game.savingsPot));
      } catch (e) {}

      game.score = Math.max(0, finalScore);
      game.necessityMeter = 50;
      game.hasKestrlCard = false;
      game.kestrlCardTimer = 0;
      game.glitchIntensity = 0;

      game.monster.x = -260;
      game.monster.targetX = -260;
      game.monster.size = 1;

      createParticles(
        game.player.x + PLAYER_WIDTH / 2,
        game.player.y,
        "#22c55e",
        25
      );
    } else {
      // true game over
      game.state = "gameover";
      game.gameOverTime = 0;
    }
  }

  // ---------- UPDATE ----------
  function update() {
    if (game.state !== "running") {
      if (game.state === "gameover") game.gameOverTime++;
      return;
    }

    game.frameCount++;
    game.distance = Math.floor((game.frameCount * game.speed) / 15);

    // speed ramp
    const distanceFactor = Math.min(game.distance / 800, 1.5);
    const targetSpeed = Math.min(INITIAL_SPEED + distanceFactor * 6, MAX_SPEED);
    if (game.speed < targetSpeed) {
      game.speed += BASE_SPEED_INCREMENT * (1 + distanceFactor);
    }

    // kestrl card timer
    if (game.hasKestrlCard) {
      game.kestrlCardTimer--;
      if (game.kestrlCardTimer <= 0) {
        game.hasKestrlCard = false;
      }
    }

    // necessity + score bleed
    game.necessityMeter = Math.max(0, game.necessityMeter - 0.03);
    if (game.necessityMeter <= 0) {
      game.score -= 0.5;
    }

    // parallax layers
    game.parallaxLayers.forEach((layer) => {
      layer.x -= game.speed * layer.speed;
      if (layer.x <= -canvas.width) layer.x += canvas.width;
    });

    // player physics
    const p = game.player;

    if (p.isSliding) {
      p.slideTimer--;
      if (p.slideTimer <= 0) p.isSliding = false;
    }

    p.velocityY += GRAVITY;
    p.y += p.velocityY;

    const playerHeight = p.isSliding ? PLAYER_SLIDE_HEIGHT : PLAYER_HEIGHT;
    if (p.y >= game.groundY - playerHeight) {
      p.y = game.groundY - playerHeight;
      p.velocityY = 0;
      p.isJumping = false;
      game.coyoteCounter = COYOTE_TIME;
    } else if (game.coyoteCounter > 0) {
      game.coyoteCounter--;
    }

    // monster chase
    const monsterBaseX = -150;
    if (game.score < 0) {
      const debt = Math.abs(game.score);
      game.monster.targetX = monsterBaseX + Math.min(debt * 1.5, p.x - 80);
      game.monster.size = 1 + Math.min(debt / 200, 1.5);
    } else {
      game.monster.targetX = monsterBaseX;
      game.monster.size = Math.max(1, game.monster.size - 0.01);
    }

    if (game.hasKestrlCard) {
      game.monster.targetX = monsterBaseX - 150;
    }

    game.monster.x += (game.monster.targetX - game.monster.x) * 0.05;

    // glitch buildup from deep debt
    if (game.score < game.debtThreshold) {
      const excessDebt =
        Math.abs(game.score) - Math.abs(game.debtThreshold);
      game.glitchIntensity = Math.min(1, excessDebt / 200);
    } else {
      game.glitchIntensity = Math.max(0, game.glitchIntensity - 0.02);
    }

    // monster catches player
    if (game.monster.x + 40 >= p.x) {
      createParticles(
        p.x + PLAYER_WIDTH / 2,
        p.y + PLAYER_HEIGHT / 2,
        "#ef4444",
        25
      );
      triggerDeath();
    }

    // spawn things
    if (game.frameCount % Math.max(60, 130 - Math.floor(game.speed * 3)) === 0) {
      spawnObstacle();
    }
    if (game.frameCount % 50 === 0) spawnCoin();
    if (game.frameCount % 120 === 0) spawnKestrlCard();

    // obstacles
    game.obstacles = game.obstacles.filter((obs) => {
      obs.x -= game.speed;

      const playerBox = {
        x: p.x,
        y: p.y,
        width: PLAYER_WIDTH - 10,
        height: playerHeight,
      };

      if (
        playerBox.x < obs.x + obs.width - 5 &&
        playerBox.x + playerBox.width > obs.x + 5 &&
        playerBox.y < obs.y + obs.height &&
        playerBox.y + playerBox.height > obs.y
      ) {
        createParticles(
          p.x + PLAYER_WIDTH / 2,
          p.y + PLAYER_HEIGHT / 2,
          "#ef4444",
          20
        );
        triggerDeath();
      }

      if (!obs.passed && obs.x + obs.width < p.x) {
        obs.passed = true;
        game.score += 5;
      }

      return obs.x > -100;
    });

    // coins
    game.coins = game.coins.filter((coin) => {
      coin.x -= game.speed;
      coin.pulsePhase += 0.1;

      const centerX = p.x + PLAYER_WIDTH / 2;
      const centerY = p.y + playerHeight / 2;
      const dx = coin.x - centerX;
      const dy = coin.y - centerY;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < coin.radius + 28) {
        if (game.hasKestrlCard) {
          game.score += 10;
          game.necessityMeter = Math.min(100, game.necessityMeter + 8);
          createParticles(coin.x, coin.y, "#06b6d4", 10);
        } else if (coin.isGreen) {
          game.greenCoins++;
          game.score += 10;
          game.necessityMeter = Math.min(100, game.necessityMeter + 12);
          createParticles(coin.x, coin.y, "#22c55e", 10);
        } else {
          game.redCoins++;
          game.score -= 50;
          game.necessityMeter = Math.min(100, game.necessityMeter + 5);
          createParticles(coin.x, coin.y, "#ef4444", 10);
          game.glitchIntensity = Math.min(1, game.glitchIntensity + 0.18);
        }
        return false;
      }

      return coin.x > -40;
    });

    // power-ups
    game.powerUps = game.powerUps.filter((pu) => {
      pu.x -= game.speed;
      pu.pulsePhase += 0.12;

      const centerX = p.x + PLAYER_WIDTH / 2;
      const centerY = p.y + playerHeight / 2;
      if (
        centerX > pu.x - 20 &&
        centerX < pu.x + pu.width + 20 &&
        centerY > pu.y - 20 &&
        centerY < pu.y + pu.height + 20
      ) {
        game.hasKestrlCard = true;
        game.kestrlCardTimer = 600;
        createParticles(
          pu.x + pu.width / 2,
          pu.y + pu.height / 2,
          "#06b6d4",
          20
        );
        game.monster.x = -260;
        game.monster.targetX = -260;
        return false;
      }

      return pu.x > -100;
    });

    // particles
    game.particles = game.particles.filter((p2) => {
      p2.x += p2.vx;
      p2.y += p2.vy;
      p2.life -= 0.03;
      return p2.life > 0;
    });

    // running dust
    if (!p.isJumping && !p.isSliding && game.frameCount % 8 === 0) {
      game.particles.push({
        x: p.x,
        y: game.groundY - 4,
        vx: -2,
        vy: -1,
        life: 0.5,
        color: "#facc15",
        size: 3,
      });
    }
  }

  // ---------- DRAW HELPERS (PIXEL ART) ----------
  function drawPixelMonster() {
    const m = game.monster;
    const intensity =
      game.score < 0 ? Math.min(1, Math.abs(game.score) / 200) : 0;

    const pixel = 4;
    const baseSize = 10; // in pixels (grid units)

    ctx.save();
    ctx.translate(m.x + 40 * m.size, game.groundY - 70 * m.size);
    ctx.scale(m.size, m.size);

    // aura
    const radius = baseSize * pixel * 1.6;
    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
    gradient.addColorStop(0, "rgba(15,23,42,0.9)");
    gradient.addColorStop(0.6, `rgba(127,29,29,${0.5 + intensity * 0.4})`);
    gradient.addColorStop(1, "rgba(15,23,42,0)");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(0, 0, radius, 0, Math.PI * 2);
    ctx.fill();

    // helper
    const drawBlock = (x, y, w, h, color) => {
      ctx.fillStyle = color;
      ctx.fillRect(x * pixel, y * pixel, w * pixel, h * pixel);
    };

    const bodyCol = "#111827";
    const highlightCol = "#1f2937";

    // chunky oval body
    for (let row = -6; row <= 6; row++) {
      const width = row < 0 ? 6 + row : 6 - row * 0.7;
      for (let col = -width; col <= width; col++) {
        const c = Math.random() > 0.75 ? highlightCol : bodyCol;
        drawBlock(col, row, 1, 1, c);
      }
    }

    // horns
    drawBlock(-5, -7, 2, 3, "#000000");
    drawBlock(3, -7, 2, 3, "#000000");

    // eyes
    ctx.shadowColor = "#f97316";
    ctx.shadowBlur = 12 + intensity * 12;
    drawBlock(-3, -3, 2, 2, "#f97316");
    drawBlock(2, -3, 2, 2, "#f97316");
    ctx.shadowBlur = 0;

    drawBlock(-2, -2, 1, 1, "#ffffff");
    drawBlock(3, -2, 1, 1, "#ffffff");

    // mouth
    for (let i = -3; i <= 3; i++) {
      const h = i % 2 === 0 ? 2 : 1;
      drawBlock(i, 2, 1, h, "#ef4444");
    }

    ctx.restore();
  }

  function drawPixelPlayer() {
    const p = game.player;
    const height = p.isSliding ? PLAYER_SLIDE_HEIGHT : PLAYER_HEIGHT;
    const pixel = 4;

    ctx.save();
    ctx.translate(p.x + PLAYER_WIDTH / 2, p.y + height / 2);

    if (p.isSliding) {
      ctx.rotate(-Math.PI / 12);
      ctx.scale(1.1, 0.7);
    }

    if (game.hasKestrlCard) {
      ctx.shadowColor = "#22c55e";
      ctx.shadowBlur = 18;
    }

    const runFrame = Math.floor(game.frameCount / 6) % 4;
    const wingFrame = p.isJumping ? 2 : runFrame;
    const legOffset = [0, -1, 0, 1][runFrame];

    const cols = {
      bodyDark: "#5c3d2e",
      bodyMid: "#8b5e3c",
      bodyLight: "#a67c52",
      wingDark: "#4a2d1a",
      wingMid: "#6b4423",
      head: "#0ea5e9",
      beak: game.hasKestrlCard ? "#22c55e" : "#eab308",
      beakLight: game.hasKestrlCard ? "#86efac" : "#facc15",
      eye: "#000000",
      eyeShine: "#ffffff",
      outline: "#111827",
    };

    const drawPx = (x, y, w, h, color) => {
      ctx.fillStyle = color;
      ctx.fillRect(x * pixel, y * pixel, w * pixel, h * pixel);
    };

    // outline box
    drawPx(-6, -6, 13, 11, cols.outline);

    // body
    drawPx(-5, -5, 11, 9, cols.bodyMid);
    drawPx(-5, -5, 9, 3, cols.bodyLight);
    drawPx(-5, 1, 11, 3, cols.bodyDark);

    // wing (flap)
    const wingY = [-3, -4, -5, -4][wingFrame];
    drawPx(-4, wingY, 6, 4, cols.wingDark);
    drawPx(-3, wingY, 4, 2, cols.wingMid);

    // head
    drawPx(4, -7, 6, 6, cols.head);
    drawPx(4, -7, 5, 2, "#38bdf8");

    // eye
    drawPx(7, -6, 2, 2, cols.eye);
    drawPx(8, -6, 1, 1, cols.eyeShine);

    // beak
    drawPx(10, -5, 3, 1, cols.beak);
    drawPx(11, -4, 2, 1, cols.beakLight);

    // tail feathers
    drawPx(-7, -1, 2, 1, cols.wingMid);
    drawPx(-8, 0, 2, 1, cols.wingDark);
    drawPx(-9, 1, 2, 1, cols.wingMid);

    // legs
    if (!p.isSliding) {
      const leg1Y = 3 + legOffset;
      const leg2Y = 3 - legOffset;
      drawPx(-1, leg1Y, 1, 3, cols.beak);
      drawPx(2, leg2Y, 1, 3, cols.beak);
    }

    ctx.shadowBlur = 0;
    ctx.restore();
  }

  // ---------- DRAW ----------
  function draw() {
    ctx.save();
    ctx.imageSmoothingEnabled = false;

    if (game.glitchIntensity > 0.25) {
      const s = game.glitchIntensity * 5;
      ctx.translate(
        (Math.random() - 0.5) * s,
        (Math.random() - 0.5) * s
      );
    }

    // NES-style sky
    const sky = ctx.createLinearGradient(0, 0, 0, canvas.height);
    sky.addColorStop(0, "#5c94fc");
    sky.addColorStop(1, "#1e40af");
    ctx.fillStyle = sky;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // simple stars
    ctx.fillStyle = "#eff6ff";
    for (let i = 0; i < 40; i++) {
      const x = (i * 173 + game.frameCount * 0.1) % canvas.width;
      const y = (i * 97) % (game.groundY - 60);
      ctx.fillRect(Math.floor(x), Math.floor(y), 1, 1);
    }

    // simple pixel mountains
    ctx.fillStyle = "#1e3a8a";
    ctx.beginPath();
    ctx.moveTo(0, canvas.height);
    ctx.lineTo(canvas.width * 0.25, game.groundY - 40);
    ctx.lineTo(canvas.width * 0.5, canvas.height);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "#1d4ed8";
    ctx.beginPath();
    ctx.moveTo(canvas.width * 0.4, canvas.height);
    ctx.lineTo(canvas.width * 0.7, game.groundY - 50);
    ctx.lineTo(canvas.width, canvas.height);
    ctx.closePath();
    ctx.fill();

    // brick ground à la Mario
    const tile = 32;
    for (let x = 0; x < canvas.width + tile; x += tile) {
      ctx.fillStyle = "#f97316";
      ctx.fillRect(x, game.groundY, tile, 16);
      ctx.fillStyle = "#ea580c";
      ctx.fillRect(x, game.groundY + 16, tile, 16);
      ctx.fillStyle = "#9a3412";
      ctx.fillRect(x, game.groundY + 32, tile, GROUND_HEIGHT - 32);

      ctx.strokeStyle = "#7c2d12";
      ctx.lineWidth = 2;
      ctx.strokeRect(x, game.groundY, tile, GROUND_HEIGHT);
    }

    // monster
    if (game.monster.x < canvas.width + 200) {
      drawPixelMonster();
    }

    // obstacles (simple purple blocks)
    game.obstacles.forEach((obs) => {
      ctx.fillStyle = "#6d28d9";
      ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
      ctx.strokeStyle = "#4c1d95";
      ctx.lineWidth = 2;
      ctx.strokeRect(obs.x, obs.y, obs.width, obs.height);
    });

    // power-ups (Kestrl card)
    game.powerUps.forEach((pu) => {
      const t = Math.sin(pu.pulsePhase) * 1.5;
      ctx.save();
      ctx.translate(pu.x + pu.width / 2, pu.y + pu.height / 2);

      const w = pu.width + t * 2;
      const h = pu.height;

      const glow = ctx.createRadialGradient(0, 0, 0, 0, 0, w);
      glow.addColorStop(0, "rgba(56,189,248,0.8)");
      glow.addColorStop(1, "rgba(56,189,248,0)");
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(0, 0, w, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#0ea5e9";
      ctx.fillRect(-w / 2, -h / 2, w, h);
      ctx.strokeStyle = "#38bdf8";
      ctx.lineWidth = 3;
      ctx.strokeRect(-w / 2, -h / 2, w, h);

      ctx.fillStyle = "#e5e7eb";
      ctx.font = "bold 16px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("K", 0, 0);

      ctx.restore();
    });

    // coins – pixel squares with glow
    game.coins.forEach((coin) => {
      const px = 4;
      const baseSize = 4;
      const pulse = Math.sin(coin.pulsePhase) * 0.5;
      const s = baseSize + pulse;

      // glow
      const glowRadius = s * px * 3;
      const glow = ctx.createRadialGradient(
        coin.x,
        coin.y,
        0,
        coin.x,
        coin.y,
        glowRadius
      );
      if (game.hasKestrlCard) {
        glow.addColorStop(0, "rgba(45,212,191,0.8)");
        glow.addColorStop(1, "rgba(45,212,191,0)");
      } else if (coin.isGreen) {
        glow.addColorStop(0, "rgba(250,204,21,0.8)");
        glow.addColorStop(1, "rgba(250,204,21,0)");
      } else {
        glow.addColorStop(0, "rgba(248,113,113,0.8)");
        glow.addColorStop(1, "rgba(248,113,113,0)");
      }
      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(coin.x, coin.y, glowRadius, 0, Math.PI * 2);
      ctx.fill();

      // square coin
      const sizePx = s * px;
      const x = Math.round(coin.x - sizePx / 2);
      const y = Math.round(coin.y - sizePx / 2);

      ctx.fillStyle = game.hasKestrlCard
        ? "#22c55e"
        : coin.isGreen
        ? "#facc15"
        : "#ef4444";
      ctx.fillRect(x, y, sizePx, sizePx);

      ctx.strokeStyle = coin.isGreen ? "#92400e" : "#7f1d1d";
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, sizePx, sizePx);

      ctx.fillStyle = "#111827";
      ctx.font = "bold 12px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(coin.isGreen ? "$" : "!", coin.x, coin.y);

      ctx.font = "12px monospace";
      if (game.hasKestrlCard || coin.isGreen) {
        ctx.fillStyle = "#bbf7d0";
        ctx.fillText("+10", coin.x, coin.y + sizePx / 2 + 12);
      } else {
        ctx.fillStyle = "#fecaca";
        ctx.fillText("-50", coin.x, coin.y + sizePx / 2 + 12);
      }
    });

    // player
    drawPixelPlayer();

    // particles
    game.particles.forEach((p2) => {
      ctx.globalAlpha = p2.life;
      ctx.fillStyle = p2.color;
      ctx.fillRect(
        Math.floor(p2.x),
        Math.floor(p2.y),
        Math.max(2, p2.size),
        Math.max(2, p2.size)
      );
    });
    ctx.globalAlpha = 1;

    // glitch overlay
    if (game.glitchIntensity > 0) {
      const t = game.glitchIntensity;
      ctx.fillStyle = `rgba(148,27,27,${0.2 * t})`;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (let y = 0; y < canvas.height; y += 3) {
        ctx.fillStyle = `rgba(0,0,0,${0.1 + 0.15 * t})`;
        ctx.fillRect(0, y, canvas.width, 1);
      }

      const noiseCount = 40 * t;
      for (let i = 0; i < noiseCount; i++) {
        const nx = Math.random() * canvas.width;
        const ny = Math.random() * canvas.height;
        ctx.fillStyle =
          Math.random() > 0.5
            ? "rgba(220,38,38,0.8)"
            : "rgba(15,23,42,0.8)";
        ctx.fillRect(nx, ny, 2, 2);
      }
    }

    drawHUD();

    ctx.restore();
  }

  // ---------- HUD ----------
  function drawHUD() {
    ctx.save();
    ctx.imageSmoothingEnabled = false;
    ctx.font = "16px monospace";
    ctx.textAlign = "left";
    ctx.textBaseline = "top";

    // Score
    ctx.fillStyle = "#020617";
    ctx.fillRect(16, 16, 160, 46);
    ctx.strokeStyle = game.score >= 0 ? "#facc15" : "#ef4444";
    ctx.lineWidth = 3;
    ctx.strokeRect(16, 16, 160, 46);
    ctx.fillStyle = "#9ca3af";
    ctx.fillText("SCORE", 24, 22);
    ctx.fillStyle = game.score >= 0 ? "#facc15" : "#f97316";
    ctx.font = "bold 20px monospace";
    ctx.fillText(Math.floor(game.score).toString(), 24, 38);

    // Distance
    ctx.font = "16px monospace";
    ctx.fillStyle = "#020617";
    ctx.fillRect(16, 72, 140, 38);
    ctx.strokeStyle = "#38bdf8";
    ctx.strokeRect(16, 72, 140, 38);
    ctx.fillStyle = "#9ca3af";
    ctx.fillText("DIST", 24, 78);
    ctx.fillStyle = "#e5e7eb";
    ctx.fillText(game.distance.toString() + "m", 24, 92);

    // Savings pot
    const spX = canvas.width - 180;
    ctx.fillStyle = "#022c22";
    ctx.fillRect(spX, 16, 164, 46);
    ctx.strokeStyle = "#22c55e";
    ctx.strokeRect(spX, 16, 164, 46);
    ctx.fillStyle = "#6ee7b7";
    ctx.fillText("SAVED (S)", spX + 8, 22);
    ctx.fillStyle = "#bbf7d0";
    ctx.font = "bold 20px monospace";
    ctx.fillText(game.savingsPot.toString(), spX + 8, 38);

    // Coins counters
    ctx.font = "14px monospace";
    ctx.fillStyle = "#020617";
    ctx.fillRect(spX, 72, 164, 38);
    ctx.strokeStyle = "#4b5563";
    ctx.strokeRect(spX, 72, 164, 38);
    ctx.fillStyle = "#facc15";
    ctx.fillText("HALAL: " + game.greenCoins, spX + 8, 78);
    ctx.fillStyle = "#fca5a5";
    ctx.fillText("RIBA: " + game.redCoins, spX + 8, 94);

    // Necessity meter
    const barX = canvas.width / 2 - 180;
    const barY = 20;
    const barW = 360;
    const barH = 22;

    ctx.fillStyle = "#020617";
    ctx.fillRect(barX, barY, barW, barH);
    ctx.strokeStyle = "#9ca3af";
    ctx.strokeRect(barX, barY, barW, barH);

    const ratio = game.necessityMeter / 100;
    const color =
      ratio > 0.6 ? "#22c55e" : ratio > 0.3 ? "#eab308" : "#ef4444";
    ctx.fillStyle = color;
    ctx.fillRect(barX + 2, barY + 2, (barW - 4) * Math.max(0, ratio), barH - 4);

    ctx.fillStyle = "#e5e7eb";
    ctx.font = "12px monospace";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(
      "NECESSITY " + Math.round(game.necessityMeter) + "%",
      barX + barW / 2,
      barY + barH / 2
    );

    // Kestrl card timer
    if (game.hasKestrlCard) {
      const secs = Math.ceil(game.kestrlCardTimer / 60);
      ctx.font = "14px monospace";
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      ctx.fillStyle = "#020617";
      ctx.fillRect(canvas.width / 2 - 80, 56, 160, 32);
      ctx.strokeStyle = "#06b6d4";
      ctx.strokeRect(canvas.width / 2 - 80, 56, 160, 32);
      ctx.fillStyle = "#67e8f9";
      ctx.fillText("KESTRL CARD: " + secs + "s", canvas.width / 2, 62);
    }

    // Game over overlay
    if (game.state === "gameover") {
      ctx.fillStyle = "rgba(15,23,42,0.7)";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = "32px monospace";
      ctx.fillStyle = "#f87171";
      ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2 - 40);

      ctx.font = "18px monospace";
      ctx.fillStyle = "#e5e7eb";
      ctx.fillText(
        "Final score: " + Math.floor(game.score),
        canvas.width / 2,
        canvas.height / 2
      );
      ctx.fillText(
        "Press SPACE / TAP to restart",
        canvas.width / 2,
        canvas.height / 2 + 40
      );
    }

    ctx.restore();
  }

  // ---------- LOOP ----------
  function gameLoop() {
    update();
    draw();
    animationId = requestAnimationFrame(gameLoop);
  }
</script>
</body>
</html>










    


